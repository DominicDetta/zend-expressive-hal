{
    "docs": [
        {
            "location": "/",
            "text": "Hypertext Application Language (HAL) for PSR-7 Applications\n\n\n\n\n\n\nThis library provides utilities for modeling HAL resources with links and\ngenerating \nPSR-7\n responses representing\nboth JSON and XML serializations of them.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-hal\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "Hypertext Application Language (HAL) for PSR-7 Applications"
        },
        {
            "location": "/#hypertext-application-language-hal-for-psr-7-applications",
            "text": "This library provides utilities for modeling HAL resources with links and\ngenerating  PSR-7  responses representing\nboth JSON and XML serializations of them.",
            "title": "Hypertext Application Language (HAL) for PSR-7 Applications"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-hal",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "zend-expressive-hal\n\n\nThis component provides tools for generating Hypertext Application Language\n(HAL) payloads for your APIs, in both JSON and XML formats.\n\n\nAt its core, it features:\n\n\n\n\nZend\\Expressive\\Hal\\Link\n, a value object for describing \nrelational links\n.\n\n\nZend\\Expressive\\Hal\\HalResource\n, a value object for describing your API\n  resource, its relational links, and any embedded/child resources related to\n  it.\n\n\n\n\nThese two tools allow you to model payloads of varying complexity.\n\n\nTo allow providing \nrepresentations\n of these, we provide\n\nZend\\Expressive\\Hal\\HalResponseFactory\n. This factory generates a\n\nPSR-7\n response for the provided resource,\nincluding its links and any embedded/child resources it composes.\n\n\nCreating link URIs by hand is error-prone, as URI schemas may change; most\nframeworks provide route-based URI generation for this reason. To address this,\nwe provide \nZend\\Expressive\\Hal\\LinkGenerator\n, and an accompanying interface,\n\nZend\\Expressive\\Hal\\LinkGenerator\\UrlGenerator\n. You may use these to generate\n\nLink\n instances that use URIs based on routes you have defined in your\napplication. We also ship \nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator\n,\nwhich provides a \nUrlGenerator\n implementation backed by the\nzend-expressive-helpers package.\n\n\nFinally, we recognize that most modern PHP applications use strong data\nmodeling, and thus API payloads need to represent PHP \nobjects\n. To facilitate\nthis, we provide two components:\n\n\n\n\nZend\\Expressive\\Hal\\Metadata\n is a subcomponent that allows mapping PHP\n  objects to how they should be represented: Should a route be used to generate\n  its self relational link? What zend-hydrator extractor should be used to\n  create a representation of the object? Does the object represent a collection?\n  etc.\n\n\nZend\\Expressive\\Hal\\ResourceGenerator\n consumes metadata in order to generate\n  \nHalResource\n instances, mapping metadata to specific representation strategies.\n\n\n\n\nThe purpose of the package is to automate creation of HAL payloads, including\nrelational links, from PHP objects.\n\n\nInstallation\n\n\nUse Composer:\n\n\n$ composer require zendframework/zend-expressive-hal\n\n\n\nIf you are adding this to an Expressive application, and have the\n\nzend-component-installer\n\npackage installed, this will prompt you to ask if you wish to add it to your\napplication configuration; please do, as the package provides a number of useful\nfactories.\n\n\nWe also recommend installing \nzend-hydrator\n,\nwhich provides facilities for extracting associative array representations of\nPHP objects:\n\n\n$ composer require zendframework/zend-hydrator\n\n\n\nFinally, if you want to provide paginated collections, we recommend installing\n\nzend-paginator\n:\n\n\n$ composer require zendframework/zend-paginator\n\n\n\nQuick Start\n\n\nThe following examples assume that you have added this package to an Expressive\napplication.\n\n\nEntity and collection classes\n\n\nFor each of our examples, we'll assume the following class exists:\n\n\nnamespace Api\\Books;\n\nclass Book\n{\n    public $id;\n    public $title;\n    public $author;\n}\n\n\n\nAdditionally, we'll have a class representing a paginated group of books:\n\n\nnamespace Api\\Books;\n\nuse Zend\\Paginator\\Paginator;\n\nclass BookCollection extends Paginator\n{\n}\n\n\n\nRoutes\n\n\nThe examples below assume that we have the following routes defined in our\napplication somehow:\n\n\n\n\n\"book\" will map to a single book by identifier: \"/api/books/{id}\"\n\n\n\"books\" will map to a queryable collection endpoint: \"/api/books\"\n\n\n\n\nCreate metadata\n\n\nIn order to allow creating representations of these classes, we need to provide\nthe resource generator with metadata describing them. This is done via\nconfiguration, which you could put in one of the following places:\n\n\n\n\nA new configuration file: \nconfig/autoload/hal.global.php\n.\n\n\nA \nConfigProvider\n class: \nApi\\Books\\ConfigProvider\n. If you go this route,\n  you will need to add an entry for this class to your \nconfig/config.php\n file.\n\n\n\n\nThe configuration will look like this:\n\n\n// Provide the following imports:\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty as ObjectPropertyHydrator;\n\n// And include the following in your configuration:\nMetadataMap::class => [\n    [\n        '__class__' => RouteBasedResourceMetadata::class,\n        'resource_class' => Book::class,\n        'route' => 'book',\n        'extractor' => ObjectPropertyHydrator::class,\n    ],\n    [\n        '__class__' => RouteBasedCollectionMetadata::class,\n        'collection_class' => BookCollection::class,\n        'collection_relation' => 'book',\n        'route' => 'books',\n    ],\n],\n\n\n\nManually creating and rendering a resource\n\n\nThe following request handler creates a \nHalResource\n with its associated links,\nand then manually renders it using \nZend\\Expressive\\Hal\\Renderer\\JsonRenderer\n.\n(An \nXmlRenderer\n is also provided, but not demonstrated here.)\n\n\nWe'll assume that \nApi\\Books\\Repository\n handles retrieving data from persistent\nstorage.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\Hal\\HalResource;\nuse Zend\\Expressive\\Hal\\Link;\nuse Zend\\Expressive\\Hal\\Renderer\\JsonRenderer;\n\nclass BookAction implements RequestHandlerInterface\n{\n    /** @var JsonRenderer */\n    private $renderer;\n\n    /** @var Repository */\n    private $repository;\n\n    public function __construct(\n        Repository $repository,\n        JsonRenderer $renderer\n    ) {\n        $this->repository = $repository;\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n        $book = $this->repository->get($id);\n        $resource = new HalResource((array) $book);\n        $resource = $resource->withLink(new Link('self'));\n        return new TextResponse(\n            $this->renderer->render($resource),\n            200,\n            ['Content-Type' => 'application/hal+json']\n        );\n    }\n}\n\n\n\nThe \nJsonRenderer\n returns the JSON string representing the data and links in\nthe resource. The payload generated might look like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}\n\n\n\nThe above example uses no metadata, and manually creates the \nHalResource\n\ninstance. As the complexity of your objects increase, and the number of objects\nyou want to represent via HAL increases, you may not want to manually generate\nthem.\n\n\nRequest handler using the ResourceGenerator and ResponseFactory\n\n\nIn this next example, our request handler will compose a\n\nZend\\Expressive\\Hal\\ResourceGenerator\n instance for generating a\n\nZend\\Expressive\\Hal\\HalResource\n from our objects, and a\n\nZend\\Expressive\\Hal\\HalResponseFactory\n for creating a response based on the\nreturned resource.\n\n\nFirst, we'll look at a handler that displays a single book. We'll assume that\n\nApi\\Books\\Repository\n handles retrieving data from persistent storage.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass BookAction implements RequestHandlerInterface\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n\n        /** @var \\Api\\Books\\Book $book */\n        $book = $this->repository->get($id);\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}\n\n\n\nNote that the \n$request\n instance is passed to both the resource generator and\nresponse factory:\n\n\n\n\nThe request is used by the resource generator during link URI generation.\n\n\nThe request is used by the response factory to determine if a JSON or XML\n  payload should be generated.\n\n\n\n\nThe generated payload might look like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}\n\n\n\nRequest handler returning a collection\n\n\nNext, we'll create a request handler that returns a \ncollection\n of books. The\ncollection will be \npaginated\n (assume our repository class creates a\n\nBookCollection\n backed by an appropriate adapter), and use a query string\nparameter to determine which page of results to return.\n\n\nnamespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass BooksAction implements RequestHandlerInterface\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $page = $request->getQueryParams()['page'] ?? 1;\n\n        /** @var \\Api\\Books\\BookCollection $books */\n        $books = $this->repository->fetchAll();\n\n        $books->setItemCountPerPage(25);\n        $books->setCurrentPageNumber($page);\n\n        $resource = $this->resourceGenerator->fromObject($books, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}\n\n\n\nNote that resource and response generation \nis exactly the same\n as our previous\nexample! This is because the metadata map takes care of the details of\nextracting the data from our value objects and generating links for us.\n\n\nIn this particular example, since we are using a paginator for our collection\nclass, we might get back something like the following:\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            },\n            /* ... */\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 25,\n    \"_total\": 407\n}\n\n\n\nNext steps\n\n\nThe above examples demonstrate setting up your application to generate and\nreturn HAL resources. In the following chapters, we'll cover:\n\n\n\n\nwhat HAL is, in depth.\n\n\nthe \nHalResource\n and \nLink\n classes, so you can create your own custom\n  resources.\n\n\nthe \nMetadataMap\n and how to both interact with it manually as well as\n  configure it. We'll also cover creating custom metadata types.\n\n\nThe \nResourceGenerator\n, and how you can map metadata types to strategies that\n  generate representations.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zend-expressive-hal",
            "text": "This component provides tools for generating Hypertext Application Language\n(HAL) payloads for your APIs, in both JSON and XML formats.  At its core, it features:   Zend\\Expressive\\Hal\\Link , a value object for describing  relational links .  Zend\\Expressive\\Hal\\HalResource , a value object for describing your API\n  resource, its relational links, and any embedded/child resources related to\n  it.   These two tools allow you to model payloads of varying complexity.  To allow providing  representations  of these, we provide Zend\\Expressive\\Hal\\HalResponseFactory . This factory generates a PSR-7  response for the provided resource,\nincluding its links and any embedded/child resources it composes.  Creating link URIs by hand is error-prone, as URI schemas may change; most\nframeworks provide route-based URI generation for this reason. To address this,\nwe provide  Zend\\Expressive\\Hal\\LinkGenerator , and an accompanying interface, Zend\\Expressive\\Hal\\LinkGenerator\\UrlGenerator . You may use these to generate Link  instances that use URIs based on routes you have defined in your\napplication. We also ship  Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator ,\nwhich provides a  UrlGenerator  implementation backed by the\nzend-expressive-helpers package.  Finally, we recognize that most modern PHP applications use strong data\nmodeling, and thus API payloads need to represent PHP  objects . To facilitate\nthis, we provide two components:   Zend\\Expressive\\Hal\\Metadata  is a subcomponent that allows mapping PHP\n  objects to how they should be represented: Should a route be used to generate\n  its self relational link? What zend-hydrator extractor should be used to\n  create a representation of the object? Does the object represent a collection?\n  etc.  Zend\\Expressive\\Hal\\ResourceGenerator  consumes metadata in order to generate\n   HalResource  instances, mapping metadata to specific representation strategies.   The purpose of the package is to automate creation of HAL payloads, including\nrelational links, from PHP objects.",
            "title": "zend-expressive-hal"
        },
        {
            "location": "/intro/#installation",
            "text": "Use Composer:  $ composer require zendframework/zend-expressive-hal  If you are adding this to an Expressive application, and have the zend-component-installer \npackage installed, this will prompt you to ask if you wish to add it to your\napplication configuration; please do, as the package provides a number of useful\nfactories.  We also recommend installing  zend-hydrator ,\nwhich provides facilities for extracting associative array representations of\nPHP objects:  $ composer require zendframework/zend-hydrator  Finally, if you want to provide paginated collections, we recommend installing zend-paginator :  $ composer require zendframework/zend-paginator",
            "title": "Installation"
        },
        {
            "location": "/intro/#quick-start",
            "text": "The following examples assume that you have added this package to an Expressive\napplication.",
            "title": "Quick Start"
        },
        {
            "location": "/intro/#entity-and-collection-classes",
            "text": "For each of our examples, we'll assume the following class exists:  namespace Api\\Books;\n\nclass Book\n{\n    public $id;\n    public $title;\n    public $author;\n}  Additionally, we'll have a class representing a paginated group of books:  namespace Api\\Books;\n\nuse Zend\\Paginator\\Paginator;\n\nclass BookCollection extends Paginator\n{\n}",
            "title": "Entity and collection classes"
        },
        {
            "location": "/intro/#routes",
            "text": "The examples below assume that we have the following routes defined in our\napplication somehow:   \"book\" will map to a single book by identifier: \"/api/books/{id}\"  \"books\" will map to a queryable collection endpoint: \"/api/books\"",
            "title": "Routes"
        },
        {
            "location": "/intro/#create-metadata",
            "text": "In order to allow creating representations of these classes, we need to provide\nthe resource generator with metadata describing them. This is done via\nconfiguration, which you could put in one of the following places:   A new configuration file:  config/autoload/hal.global.php .  A  ConfigProvider  class:  Api\\Books\\ConfigProvider . If you go this route,\n  you will need to add an entry for this class to your  config/config.php  file.   The configuration will look like this:  // Provide the following imports:\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty as ObjectPropertyHydrator;\n\n// And include the following in your configuration:\nMetadataMap::class => [\n    [\n        '__class__' => RouteBasedResourceMetadata::class,\n        'resource_class' => Book::class,\n        'route' => 'book',\n        'extractor' => ObjectPropertyHydrator::class,\n    ],\n    [\n        '__class__' => RouteBasedCollectionMetadata::class,\n        'collection_class' => BookCollection::class,\n        'collection_relation' => 'book',\n        'route' => 'books',\n    ],\n],",
            "title": "Create metadata"
        },
        {
            "location": "/intro/#manually-creating-and-rendering-a-resource",
            "text": "The following request handler creates a  HalResource  with its associated links,\nand then manually renders it using  Zend\\Expressive\\Hal\\Renderer\\JsonRenderer .\n(An  XmlRenderer  is also provided, but not demonstrated here.)  We'll assume that  Api\\Books\\Repository  handles retrieving data from persistent\nstorage.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\Hal\\HalResource;\nuse Zend\\Expressive\\Hal\\Link;\nuse Zend\\Expressive\\Hal\\Renderer\\JsonRenderer;\n\nclass BookAction implements RequestHandlerInterface\n{\n    /** @var JsonRenderer */\n    private $renderer;\n\n    /** @var Repository */\n    private $repository;\n\n    public function __construct(\n        Repository $repository,\n        JsonRenderer $renderer\n    ) {\n        $this->repository = $repository;\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n        $book = $this->repository->get($id);\n        $resource = new HalResource((array) $book);\n        $resource = $resource->withLink(new Link('self'));\n        return new TextResponse(\n            $this->renderer->render($resource),\n            200,\n            ['Content-Type' => 'application/hal+json']\n        );\n    }\n}  The  JsonRenderer  returns the JSON string representing the data and links in\nthe resource. The payload generated might look like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}  The above example uses no metadata, and manually creates the  HalResource \ninstance. As the complexity of your objects increase, and the number of objects\nyou want to represent via HAL increases, you may not want to manually generate\nthem.",
            "title": "Manually creating and rendering a resource"
        },
        {
            "location": "/intro/#request-handler-using-the-resourcegenerator-and-responsefactory",
            "text": "In this next example, our request handler will compose a Zend\\Expressive\\Hal\\ResourceGenerator  instance for generating a Zend\\Expressive\\Hal\\HalResource  from our objects, and a Zend\\Expressive\\Hal\\HalResponseFactory  for creating a response based on the\nreturned resource.  First, we'll look at a handler that displays a single book. We'll assume that Api\\Books\\Repository  handles retrieving data from persistent storage.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass BookAction implements RequestHandlerInterface\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new RuntimeException('No book identifier provided', 400);\n        }\n\n        /** @var \\Api\\Books\\Book $book */\n        $book = $this->repository->get($id);\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}  Note that the  $request  instance is passed to both the resource generator and\nresponse factory:   The request is used by the resource generator during link URI generation.  The request is used by the response factory to determine if a JSON or XML\n  payload should be generated.   The generated payload might look like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books/1234\" }\n    },\n    \"id\": 1234,\n    \"title\": \"Hitchhiker's Guide to the Galaxy\",\n    \"author\": \"Adams, Douglas\"\n}",
            "title": "Request handler using the ResourceGenerator and ResponseFactory"
        },
        {
            "location": "/intro/#request-handler-returning-a-collection",
            "text": "Next, we'll create a request handler that returns a  collection  of books. The\ncollection will be  paginated  (assume our repository class creates a BookCollection  backed by an appropriate adapter), and use a query string\nparameter to determine which page of results to return.  namespace Api\\Books\\Action;\n\nuse Api\\Books\\Repository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse RuntimeException;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass BooksAction implements RequestHandlerInterface\n{\n    /** @var Repository */\n    private $repository;\n\n    /** @var ResourceGenerator */\n    private $resourceGenerator;\n\n    /** @var HalResponseFactory */\n    private $responseFactory;\n\n    public function __construct(\n        Repository $repository,\n        ResourceGenerator $resourceGenerator,\n        HalResponseFactory $responseFactory\n    ) {\n        $this->repository = $repository;\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $page = $request->getQueryParams()['page'] ?? 1;\n\n        /** @var \\Api\\Books\\BookCollection $books */\n        $books = $this->repository->fetchAll();\n\n        $books->setItemCountPerPage(25);\n        $books->setCurrentPageNumber($page);\n\n        $resource = $this->resourceGenerator->fromObject($books, $request);\n        return $this->responseFactory->createResponse($request, $resource);\n    }\n}  Note that resource and response generation  is exactly the same  as our previous\nexample! This is because the metadata map takes care of the details of\nextracting the data from our value objects and generating links for us.  In this particular example, since we are using a paginator for our collection\nclass, we might get back something like the following:  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            },\n            /* ... */\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 25,\n    \"_total\": 407\n}",
            "title": "Request handler returning a collection"
        },
        {
            "location": "/intro/#next-steps",
            "text": "The above examples demonstrate setting up your application to generate and\nreturn HAL resources. In the following chapters, we'll cover:   what HAL is, in depth.  the  HalResource  and  Link  classes, so you can create your own custom\n  resources.  the  MetadataMap  and how to both interact with it manually as well as\n  configure it. We'll also cover creating custom metadata types.  The  ResourceGenerator , and how you can map metadata types to strategies that\n  generate representations.",
            "title": "Next steps"
        },
        {
            "location": "/hal/",
            "text": "Hypertext Application Language\n\n\nHypertext Application Language\n, or\nHAL) is a \nproposed IETF specification\n\nfor representing API resources and their relations with hyperlinks. While the\noriginal specification targets JSON, an additional IETF proposal\n\ntargets XML\n.\n\n\nHAL is a minimal specification, and addresses three specific things:\n\n\n\n\nHow to represent the elements of an API resource.\n\n\nHow to represent hypertext links of an API resource.\n\n\nHow to represent child resources.\n\n\n\n\nResources\n\n\nHAL opts to keep out of the way. Where other specifications may push the data\nfor a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL\nspecifies resources as the primary payload.\n\n\nAs such, a resource is simply a \ndocument\n:\n\n\n{\n  \"id\": \"XXXX-YYYY-ZZZZ-AAAA\",\n  \"title\": \"Life, the Universe, and Everything\",\n  \"author\": \"Adams, Douglas\"\n}\n\n\n\nFor XML documents, the element \n<resource>\n is reserved to detail the resource;\nevery other element represents the document:\n\n\n<resource>\n  <id>XXXX-YYYY-ZZZZ-AAAA</id>\n  <title>Life, the Universe, and Everything</title>\n  <author>Adams, Douglas</author>\n</resource>\n\n\n\nThis decision makes both consuming and generating HAL payloads trivial.\n\n\nLinks\n\n\nOne goal of REST is to allow any given resource to provide \nhypertext controls\n,\nor \nlinks\n, allowing the consumer to know what they can do next. Most resources\nwill provide a \nself relational link\n, so that the consumer knows how to request\nthe resource again. However, a consumer might want to know what other actions\nare possible. For example, they may want to know:\n\n\n\n\nhow to get a list of related resources\n\n\nhow to access the first, previous, next, or last pages of a collection of\n  resources\n\n\nwhat resources are related: e.g., transactions, products, invoices, users,\n  etc.\n\n\n\n\nHAL addresses \nhow\n to provide such links. This is necessary because JSON has no\nspecific semantics around linking, and XML, while it has \nsome\n semantics, does\nnot cover how to provide \nmultiple\n links for a given element.\n\n\nHAL addresses JSON by reserving a special \n_links\n property, and specifying a\nstructure for how links are represented. Each element of the \n_links\n property\nis named for the link relation, and the value is either an array, or a link\nobject. A link object contains minimally an \nhref\n property, with several other\nproperties allowed. As an example:\n\n\n{\n  \"_links\": {\n    \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" },\n    \"books\": { \"href\": \"/api/books\" }\n  }\n}\n\n\n\nAt this point, the consumer knows they can access the current resource via the\n\"self\" relation, and a collection of \"books\" via the URI \"/api/books\".\n\n\nHAL addresses links in XML with two semantics. First, the \n<resource>\n element\ncan contain linking information, using the \"rel\" and \"href\" attributes (and any\nothers necessary to describe the link).  Typically, the \"self\" relational link\nis defined in the \n<resource>\n element. Second, the specification also reserves\nthe \n<link>\n element; the relation, URI, and other attributes become attributes\nof that XML element.\n\n\nAn equivalent XML document to the JSON document above looks like the following:\n\n\n<resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\">\n  <link rel=\"books\" href=\"/api/books\"/>\n</resource>\n\n\n\nChild Resources\n\n\nAn API payload may have \nchild resources\n for several reasons:\n\n\n\n\nThe resource may be related to the current payload, and providing it directly\n  would prevent another request to the API.\n\n\nThe payload may represent a \ncollection\n of resources (or even \nmultiple\n\n  collections of resources).\n\n\n\n\nGenerally, a child resource represents a \nrelation\n. As such, HAL has very\nspecific semantics for providing them.\n\n\nIn JSON documents, the specification reserves the property \n_embedded\n. This is\nan object, with the keys being the \nrelations\n, and the values either resources,\nor arrays of resources. Each resource follows the same structure as a basic\nHAL resource, with a \n_links\n member, other members representing the resource,\nand optionally an \n_embedded\n member.\n\n\n{\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            }\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 2,\n    \"_total\": 33\n}\n\n\n\nThe above represents a \ncollection\n of \nbook\n resources.\n\n\nTo address XML, the specification uses the \n<resource>\n element to embed\nadditional resources. Resources of the same type use the same \nrel\n attribute.\nThe XML equivalent of the above JSON documentation thus becomes:\n\n\n<resource rel=\"self\" href=\"/api/books?page=7\">\n    <link rel=\"first\" href=\"/api/books?page=1\"/>\n    <link rel=\"prev\" href=\"/api/books?page=6\"/>\n    <link rel=\"next\" href=\"/api/books?page=8\"/>\n    <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/>\n    <resource rel=\"book\" href=\"/api/books/1234\">\n        <id>1234</id>\n        <title>Hitchhiker's Guide to the Galaxy</title>\n        <author>Adams, Douglas</author>\n    </resource>\n    <resource rel=\"book\" href=\"/api/books/6789\">\n        <id>6789</id>\n        <title>Ancillary Justice</title>\n        <author>Leckie, Ann</author>\n    </resource>\n    <_page>7</_page>\n    <_per_page>2</_per_page>\n    <_total>33</_total>\n</resource>\n\n\n\nSummary\n\n\nWith these three semantics \u2014 resources, links, and child resources \u2014\nHAL allows you to describe any payload, and provide the hypertext controls\nnecessary to allow API consumers to know what resources they can access next.\n\n\nThe next step, then, is learning how to create HAL payloads for your API!",
            "title": "HAL"
        },
        {
            "location": "/hal/#hypertext-application-language",
            "text": "Hypertext Application Language , or\nHAL) is a  proposed IETF specification \nfor representing API resources and their relations with hyperlinks. While the\noriginal specification targets JSON, an additional IETF proposal targets XML .  HAL is a minimal specification, and addresses three specific things:   How to represent the elements of an API resource.  How to represent hypertext links of an API resource.  How to represent child resources.",
            "title": "Hypertext Application Language"
        },
        {
            "location": "/hal/#resources",
            "text": "HAL opts to keep out of the way. Where other specifications may push the data\nfor a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL\nspecifies resources as the primary payload.  As such, a resource is simply a  document :  {\n  \"id\": \"XXXX-YYYY-ZZZZ-AAAA\",\n  \"title\": \"Life, the Universe, and Everything\",\n  \"author\": \"Adams, Douglas\"\n}  For XML documents, the element  <resource>  is reserved to detail the resource;\nevery other element represents the document:  <resource>\n  <id>XXXX-YYYY-ZZZZ-AAAA</id>\n  <title>Life, the Universe, and Everything</title>\n  <author>Adams, Douglas</author>\n</resource>  This decision makes both consuming and generating HAL payloads trivial.",
            "title": "Resources"
        },
        {
            "location": "/hal/#links",
            "text": "One goal of REST is to allow any given resource to provide  hypertext controls ,\nor  links , allowing the consumer to know what they can do next. Most resources\nwill provide a  self relational link , so that the consumer knows how to request\nthe resource again. However, a consumer might want to know what other actions\nare possible. For example, they may want to know:   how to get a list of related resources  how to access the first, previous, next, or last pages of a collection of\n  resources  what resources are related: e.g., transactions, products, invoices, users,\n  etc.   HAL addresses  how  to provide such links. This is necessary because JSON has no\nspecific semantics around linking, and XML, while it has  some  semantics, does\nnot cover how to provide  multiple  links for a given element.  HAL addresses JSON by reserving a special  _links  property, and specifying a\nstructure for how links are represented. Each element of the  _links  property\nis named for the link relation, and the value is either an array, or a link\nobject. A link object contains minimally an  href  property, with several other\nproperties allowed. As an example:  {\n  \"_links\": {\n    \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" },\n    \"books\": { \"href\": \"/api/books\" }\n  }\n}  At this point, the consumer knows they can access the current resource via the\n\"self\" relation, and a collection of \"books\" via the URI \"/api/books\".  HAL addresses links in XML with two semantics. First, the  <resource>  element\ncan contain linking information, using the \"rel\" and \"href\" attributes (and any\nothers necessary to describe the link).  Typically, the \"self\" relational link\nis defined in the  <resource>  element. Second, the specification also reserves\nthe  <link>  element; the relation, URI, and other attributes become attributes\nof that XML element.  An equivalent XML document to the JSON document above looks like the following:  <resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\">\n  <link rel=\"books\" href=\"/api/books\"/>\n</resource>",
            "title": "Links"
        },
        {
            "location": "/hal/#child-resources",
            "text": "An API payload may have  child resources  for several reasons:   The resource may be related to the current payload, and providing it directly\n  would prevent another request to the API.  The payload may represent a  collection  of resources (or even  multiple \n  collections of resources).   Generally, a child resource represents a  relation . As such, HAL has very\nspecific semantics for providing them.  In JSON documents, the specification reserves the property  _embedded . This is\nan object, with the keys being the  relations , and the values either resources,\nor arrays of resources. Each resource follows the same structure as a basic\nHAL resource, with a  _links  member, other members representing the resource,\nand optionally an  _embedded  member.  {\n    \"_links\": {\n        \"self\": { \"href\": \"/api/books?page=7\" },\n        \"first\": { \"href\": \"/api/books?page=1\" },\n        \"prev\": { \"href\": \"/api/books?page=6\" },\n        \"next\": { \"href\": \"/api/books?page=8\" },\n        \"last\": { \"href\": \"/api/books?page=17\" }\n        \"search\": {\n            \"href\": \"/api/books?query={searchTerms}\",\n            \"templated\": true\n        }\n    },\n    \"_embedded\": {\n        \"book\": [\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/1234\" }\n                }\n                \"id\": 1234,\n                \"title\": \"Hitchhiker's Guide to the Galaxy\",\n                \"author\": \"Adams, Douglas\"\n            },\n            {\n                \"_links\": {\n                    \"self\": { \"href\": \"/api/books/6789\" }\n                }\n                \"id\": 6789,\n                \"title\": \"Ancillary Justice\",\n                \"author\": \"Leckie, Ann\"\n            }\n        ]\n    },\n    \"_page\": 7,\n    \"_per_page\": 2,\n    \"_total\": 33\n}  The above represents a  collection  of  book  resources.  To address XML, the specification uses the  <resource>  element to embed\nadditional resources. Resources of the same type use the same  rel  attribute.\nThe XML equivalent of the above JSON documentation thus becomes:  <resource rel=\"self\" href=\"/api/books?page=7\">\n    <link rel=\"first\" href=\"/api/books?page=1\"/>\n    <link rel=\"prev\" href=\"/api/books?page=6\"/>\n    <link rel=\"next\" href=\"/api/books?page=8\"/>\n    <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/>\n    <resource rel=\"book\" href=\"/api/books/1234\">\n        <id>1234</id>\n        <title>Hitchhiker's Guide to the Galaxy</title>\n        <author>Adams, Douglas</author>\n    </resource>\n    <resource rel=\"book\" href=\"/api/books/6789\">\n        <id>6789</id>\n        <title>Ancillary Justice</title>\n        <author>Leckie, Ann</author>\n    </resource>\n    <_page>7</_page>\n    <_per_page>2</_per_page>\n    <_total>33</_total>\n</resource>",
            "title": "Child Resources"
        },
        {
            "location": "/hal/#summary",
            "text": "With these three semantics \u2014 resources, links, and child resources \u2014\nHAL allows you to describe any payload, and provide the hypertext controls\nnecessary to allow API consumers to know what resources they can access next.  The next step, then, is learning how to create HAL payloads for your API!",
            "title": "Summary"
        },
        {
            "location": "/links-and-resources/",
            "text": "Links and Resources\n\n\nThe basic building blocks of this component are links and resources:\n\n\n\n\nZend\\Expressive\\Hal\\Link\n\n\nZend\\Expressive\\Hal\\HalResource\n\n\n\n\n\n\nNote on naming\n\n\nWhy \nHalResource\n and not the simpler \nResource\n? The answer: PHP. As of PHP\n7, \nresource\n has been designated a potential future language keyword. In\norder to be forwards compatible, we opted to name our class \nHalResource\n.\n\n\nPSR-13\n\n\nzendframework/zend-expressive-hal implements \nPSR-13\n,\nwhich provides interfaces for relational links and collections of relational\nlinks. \nZend\\Expressive\\Hal\\Link\n implements \nPsr\\Link\\EvolvableLinkInterface\n, and\n\nZend\\Expressive\\Hal\\HalResource\n implements \nPsr\\Link\\EvolvableLinkProviderInterface\n.\n\n\n\n\nResources compose links, so we'll cover links first.\n\n\nLinks\n\n\nLinks provide URIs to related resources.\n\n\nAny given link, therefore, needs to compose the \nrelation\n and a \nURI\n.\nAdditionally, links:\n\n\n\n\ncan be \ntemplated\n. Templated links have one or more \n{variable}\n placeholders\n  in them that clients can then fill in in order to generate a fully qualified\n  URI.\n\n\ncan contain a number of other attributes: type, title, name, etc.\n\n\n\n\nTo model these, we provide the \nZend\\Expressive\\Hal\\Link\n class. It has the\nfollowing constructor:\n\n\npublic function __construct(\n    $relation,\n    string $uri = '',\n    bool $isTemplated = false,\n    array $attributes = []\n)\n\n\n\n$relation\n can be a string value, or an array of string values, representing\nthe relation.\n\n\nTo access these various properties, you can use the following methods:\n\n\n$link->getRels()       // get the list of relations for the link\n$link->getHref()       // retrieve the URI\n$link->isTemplated()   // is the link templated?\n$link->getAttributes() // get any additional link attributes\n\n\n\nA \nLink\n is \nimmutable\n; you cannot change it after the fact. If you need a\nmodified version of the link, we provide several methods that will return \nnew\ninstances\n containing the changes:\n\n\n$link = $link->withRel($rel);    // or provide an array of relations\n$link = $link->withoutRel($rel); // or provide an array of relations\n$link = $link->withHref($href);\n$link = $link->withAttribute($attribute, $value);\n$link = $link->withoutAttribute($attribute);\n\n\n\nWith these tools, you can describe any relational link.\n\n\nRoute-based link URIs\n\n\nMost frameworks provide routing capabilities, and delegate URI generation to\ntheir routers to ensure that generated links conform to known routing\nspecifications. \nLink\n expects only a string URI, however; how can you prevent\nhard-coding that URI?\n\n\nThis component provides a tool for that: \nZend\\Expressive\\Hal\\LinkGenerator\n.\nThis class composes a \nZend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface\n\ninstance, which defines the following:\n\n\nnamespace Zend\\Expressive\\Hal\\LinkGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface UrlGeneratorInterface\n{\n    /**\n     * Generate a URL for use as the HREF of a link.\n     *\n     * - The request is provided, to allow the implementation to pull any\n     *   request-specific items it may need (e.g., results of routing, original\n     *   URI for purposes of generating a fully-qualified URI, etc.).\n     *\n     * - `$routeParams` are any replacements to make in the route string.\n     *\n     * - `$queryParams` are any query string parameters to include in the\n     *   generated URL.\n     */\n    public function generate(\n        ServerRequestInterface $request,\n        string $routeName,\n        array $routeParams = [],\n        array $queryParams = []\n    ) : string;\n}\n\n\n\nWe provide a default implementation for Expressive users,\n\nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator\n,  that uses the\n\nUrlHelper\n and \nServerUrlHelper\n from zend-expressive-helpers in order to\ngenerate URIs.\n\n\nThe \nLinkGenerator\n itself defines two methods:\n\n\n$link = $linkGenerator->fromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n$link = $linkGenerator->templatedFromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n\n\nfromRoute()\n will generate a non-templated \nLink\n instance, while\n\ntemplatedFromRoute()\n generates a templated instance.\n\n\nIf you need to generate custom links based on routing, we recommend composing\nthe \nLinkGenerator\n in your own classes to do so.\n\n\n\n\nLimitation\n\n\nThere is a \nknown limitation\n\nwith zend-router when using routes with optional parameters (e.g., \n/books[/:id]\n,\nwhere \n:id\n is optional). In such cases, if no matching parameter is provided\n(such as when generating a URI without an \n:id\n), the router will raise an\nexception due to the missing parameter.\n\n\nIf you encounter this issue, create separate routing entries for each optional\nparameter. See the issue for a comprehensive example.\n\n\n\n\nResources\n\n\nA HAL resource is simply the representation you want to return for your API.\n\nZend\\Expressive\\Hal\\HalResource\n allows you to model these representations,\nalong with any relational links and child resources.\n\n\nIt defines the following constructor:\n\n\npublic function __construct(\n    array $data = [],\n    array $links = [],\n    array $embedded = []\n)\n\n\n\n$data\n should be an associative array of data you wish to include in your\nrepresentation; the only limitation is you may not use the keys \n_links\n or\n\n_embedded\n, as these are reserved keywords.\n\n\n$links\n should be an array of \nZend\\Expressive\\Hal\\Link\n instances.\n\n\n$embedded\n should be an array of \nZend\\Expressive\\Hal\\HalResource\n instances.\nMost often, however, you will include these with \n$data\n, as the class contains\nlogic for identifying them.\n\n\nOnce you have created an instance, you can access its properties:\n\n\n$resource->getElement($name) // retrieve an element or embedded resource by name\n$resource->getElements()     // retrieve all elements and embedded resources\n$resource->getLinks()        // retrieve all relational links\n$resource->getLinksByRel()   // retrieve links for a specific relation\n$resource->toArray()         // retrieve associative array representation\n\n\n\nHalResource\n instances are \nimmutable\n. We provide a number of methods that\nallow you to create \nnew instances\n with changes:\n\n\n$resource = $resource->withElement($name, $value);\n$resource = $resource->withoutElement($name);\n$resource = $resource->withElements($elements);\n$resource = $resource->embed($name, $resource);\n$resource = $resource->withLink($link);\n$resource = $resource->withoutLink($link);\n\n\n\nWith these tools, you can describe any resource you want to represent.",
            "title": "Links and Resources"
        },
        {
            "location": "/links-and-resources/#links-and-resources",
            "text": "The basic building blocks of this component are links and resources:   Zend\\Expressive\\Hal\\Link  Zend\\Expressive\\Hal\\HalResource",
            "title": "Links and Resources"
        },
        {
            "location": "/links-and-resources/#note-on-naming",
            "text": "Why  HalResource  and not the simpler  Resource ? The answer: PHP. As of PHP\n7,  resource  has been designated a potential future language keyword. In\norder to be forwards compatible, we opted to name our class  HalResource .",
            "title": "Note on naming"
        },
        {
            "location": "/links-and-resources/#psr-13",
            "text": "zendframework/zend-expressive-hal implements  PSR-13 ,\nwhich provides interfaces for relational links and collections of relational\nlinks.  Zend\\Expressive\\Hal\\Link  implements  Psr\\Link\\EvolvableLinkInterface , and Zend\\Expressive\\Hal\\HalResource  implements  Psr\\Link\\EvolvableLinkProviderInterface .   Resources compose links, so we'll cover links first.",
            "title": "PSR-13"
        },
        {
            "location": "/links-and-resources/#links",
            "text": "Links provide URIs to related resources.  Any given link, therefore, needs to compose the  relation  and a  URI .\nAdditionally, links:   can be  templated . Templated links have one or more  {variable}  placeholders\n  in them that clients can then fill in in order to generate a fully qualified\n  URI.  can contain a number of other attributes: type, title, name, etc.   To model these, we provide the  Zend\\Expressive\\Hal\\Link  class. It has the\nfollowing constructor:  public function __construct(\n    $relation,\n    string $uri = '',\n    bool $isTemplated = false,\n    array $attributes = []\n)  $relation  can be a string value, or an array of string values, representing\nthe relation.  To access these various properties, you can use the following methods:  $link->getRels()       // get the list of relations for the link\n$link->getHref()       // retrieve the URI\n$link->isTemplated()   // is the link templated?\n$link->getAttributes() // get any additional link attributes  A  Link  is  immutable ; you cannot change it after the fact. If you need a\nmodified version of the link, we provide several methods that will return  new\ninstances  containing the changes:  $link = $link->withRel($rel);    // or provide an array of relations\n$link = $link->withoutRel($rel); // or provide an array of relations\n$link = $link->withHref($href);\n$link = $link->withAttribute($attribute, $value);\n$link = $link->withoutAttribute($attribute);  With these tools, you can describe any relational link.",
            "title": "Links"
        },
        {
            "location": "/links-and-resources/#route-based-link-uris",
            "text": "Most frameworks provide routing capabilities, and delegate URI generation to\ntheir routers to ensure that generated links conform to known routing\nspecifications.  Link  expects only a string URI, however; how can you prevent\nhard-coding that URI?  This component provides a tool for that:  Zend\\Expressive\\Hal\\LinkGenerator .\nThis class composes a  Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface \ninstance, which defines the following:  namespace Zend\\Expressive\\Hal\\LinkGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface UrlGeneratorInterface\n{\n    /**\n     * Generate a URL for use as the HREF of a link.\n     *\n     * - The request is provided, to allow the implementation to pull any\n     *   request-specific items it may need (e.g., results of routing, original\n     *   URI for purposes of generating a fully-qualified URI, etc.).\n     *\n     * - `$routeParams` are any replacements to make in the route string.\n     *\n     * - `$queryParams` are any query string parameters to include in the\n     *   generated URL.\n     */\n    public function generate(\n        ServerRequestInterface $request,\n        string $routeName,\n        array $routeParams = [],\n        array $queryParams = []\n    ) : string;\n}  We provide a default implementation for Expressive users, Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator ,  that uses the UrlHelper  and  ServerUrlHelper  from zend-expressive-helpers in order to\ngenerate URIs.  The  LinkGenerator  itself defines two methods:  $link = $linkGenerator->fromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);\n\n$link = $linkGenerator->templatedFromRoute(\n    $relation,\n    $request,\n    $routeName,\n    $routeParams, // Array of additional route parameters to inject\n    $queryParams, // Array of query string arguments to inject\n    $attributes   // Array of Link attributes to use\n);  fromRoute()  will generate a non-templated  Link  instance, while templatedFromRoute()  generates a templated instance.  If you need to generate custom links based on routing, we recommend composing\nthe  LinkGenerator  in your own classes to do so.",
            "title": "Route-based link URIs"
        },
        {
            "location": "/links-and-resources/#limitation",
            "text": "There is a  known limitation \nwith zend-router when using routes with optional parameters (e.g.,  /books[/:id] ,\nwhere  :id  is optional). In such cases, if no matching parameter is provided\n(such as when generating a URI without an  :id ), the router will raise an\nexception due to the missing parameter.  If you encounter this issue, create separate routing entries for each optional\nparameter. See the issue for a comprehensive example.",
            "title": "Limitation"
        },
        {
            "location": "/links-and-resources/#resources",
            "text": "A HAL resource is simply the representation you want to return for your API. Zend\\Expressive\\Hal\\HalResource  allows you to model these representations,\nalong with any relational links and child resources.  It defines the following constructor:  public function __construct(\n    array $data = [],\n    array $links = [],\n    array $embedded = []\n)  $data  should be an associative array of data you wish to include in your\nrepresentation; the only limitation is you may not use the keys  _links  or _embedded , as these are reserved keywords.  $links  should be an array of  Zend\\Expressive\\Hal\\Link  instances.  $embedded  should be an array of  Zend\\Expressive\\Hal\\HalResource  instances.\nMost often, however, you will include these with  $data , as the class contains\nlogic for identifying them.  Once you have created an instance, you can access its properties:  $resource->getElement($name) // retrieve an element or embedded resource by name\n$resource->getElements()     // retrieve all elements and embedded resources\n$resource->getLinks()        // retrieve all relational links\n$resource->getLinksByRel()   // retrieve links for a specific relation\n$resource->toArray()         // retrieve associative array representation  HalResource  instances are  immutable . We provide a number of methods that\nallow you to create  new instances  with changes:  $resource = $resource->withElement($name, $value);\n$resource = $resource->withoutElement($name);\n$resource = $resource->withElements($elements);\n$resource = $resource->embed($name, $resource);\n$resource = $resource->withLink($link);\n$resource = $resource->withoutLink($link);  With these tools, you can describe any resource you want to represent.",
            "title": "Resources"
        },
        {
            "location": "/resource-generator/",
            "text": "Generating Resources from PHP Objects\n\n\nIn the previous chapter, \nwe discussed links and resources\n.\nThe primitive objects allow us to create representations easily, but do not\nanswer one critical question: how can we create resources based on existing PHP\nobject types?\n\n\nTo answer that question, we provide two related features: metadata, and a\nresource generator.\n\n\nMetadata\n\n\nMetadata allows you to detail the requirements for generating a HAL\nrepresentation of a PHP object. Metadata might include:\n\n\n\n\nThe PHP class name to represent.\n\n\nA URI to use for the generated resource's self relational link.\n\n\nAlternately, routing information to use with the \nLinkGenerator\n.\n\n\nA zend-hydrator extractor to use to serialize the object to a representation.\n\n\nWhether or not the resource is a collection, and, if so, whether pagination is\n  handled as a path parameter or a query string argument, the name of the\n  parameter, etc.\n\n\n\n\nAll metadata types inherit from \nZend\\Expressive\\Hal\\Metadata\\AbstractMetadata\n,\nwhich defines a single method, \ngetClass()\n, for retrieving the name of the PHP\nclass to represent; all metadata are expected to inherit from this class.\n\n\nThe component also provides four concrete metadata types, requiring the\nfollowing information:\n\n\n\n\nZend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$collectionRelation\n\n\nstring \n$route\n\n\nstring \n$paginationParam = 'page'\n (name of the parameter indicating the\n  current page of results)\n\n\nstring \n$paginationParamType = self::TYPE_QUERY\n (one of \"query\" or \"placeholder\")\n\n\narray \n$routeParams = []\n (associative array of substitutions to use with\n  the designated route)\n\n\narray \n$queryStringArguments = []\n (associative array of query string\n  arguments to include in the generated URI)\n\n\n\n\n\n\nZend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$route\n\n\nstring \n$extractor\n (string service name of the zend-hydrator hydrator to\n  use for extracting data from the instance)\n\n\nstring \n$resourceIdentifier = 'id'\n (name of the property uniquely\n  identifying the resource)\n\n\nstring \n$routeIdentifierPlaceholder = 'id'\n (name of the routing parameter\n  that maps to the resource identifier)\n\n\narray \n$routeParams = []\n (associative array of additional routing\n  parameters to substitute when generating the URI)\n\n\n\n\n\n\nZend\\Expressive\\Hal\\Metadata\\UrlBasedCollectionMetadata\n:\n\n\nstring \n$class\n\n\nstring \n$collectionRelation\n\n\nstring \n$url\n\n\nstring \n$paginationParam = 'page'\n (name of the parameter indicating the\n  current page of results)\n\n\nstring \n$paginationParamType = self::TYPE_QUERY\n (one of \"query\" or \"placeholder\")\n\n\n\n\n\n\nZend\\Expressive\\Hal\\Metadata\\UrlBasedResourceMetadata\n\n\nstring \n$class\n\n\nstring \n$url\n\n\nstring \n$extractor\n (string service name of the zend-hydrator hydrator to\n    use for extracting data from the instance)\n\n\n\n\n\n\n\n\nWe aggregate metadata in a \nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n instance:\n\n\n$bookMetadata = new RouteBasedResourceMetadata(\n    Book::class,\n    'book',\n    ObjectPropertyHydrator::class\n);\n$booksMetadata = new RouteBasedCollectionMetadata(\n    BookCollection::class,\n    'book',\n    'books',\n);\n\n$metadataMap = new MetadataMap();\n$metadataMap->add($bookMetadata);\n$metadataMap->add($booksMetadata);\n\n\n\nConfiguration-based metadata\n\n\nTo automate generation of the \nMetadataMap\n, we provide\n\nZend\\Expressive\\Hal\\Metadata\\MetadataMapFactory\n. This factory may be used with any\n\nPSR-11\n container. It utilizes the \nconfig\n\nservice, and pulls its configuration from a key named after the\n\nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n class.\n\n\nEach item in the map will be an associative array. The member \n__class__\n will\ndescribe which metadata class to create, and the remaining properties will then\nbe used to generate an instance. As an example, the above could be configured as\nfollows:\n\n\nuse Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty;\n\nreturn [\n    'Zend\\Expressive\\Hal\\Metadata\\MetadataMap' => [\n        [\n            '__class__' => RouteBasedResourceMetadata::class,\n            'resource_class' => Book::class,\n            'route' => 'book',\n            'extractor' => ObjectProperty::class,\n        ],\n        [\n            '__class__' => RouteBasedCollectionMetadata::class,\n            'collection_class' => BookCollection::class,\n            'collection_relation' => 'book',\n            'route' => 'books',\n        ],\n    ],\n];\n\n\n\nThe rest of the parameters follow underscore delimiter naming convention:\n\n\n\n\nRouteBasedResourceMetadata::class\n\n\nresource_identifier\n (name of the property uniquely identifying the resource)\n\n\nroute_identifier_placeholder\n (name of the routing parameter that maps to the resource identifier)\n\n\nroute_params\n (associative array of substitutions to use with the designated route)\n\n\n\n\n\n\nRouteBasedCollectionMetadata::class\n\n\npagination_param\n  (name of the parameter indicating the current page of results)\n\n\npagination_param_type\n (one of \"query\" or \"placeholder\")\n\n\nroute_params\n (associative array of substitutions to use with the designated route)\n\n\nquery_string_arguments\n (associative array of additional routing parameters to substitute when generating the URI)\n\n\n\n\n\n\nUrlBasedResourceMetadata::class\n\n\nresource_class\n\n\nurl\n\n\nextractor\n\n\n\n\n\n\nUrlBasedCollectionMetadata::class\n\n\ncollection_class\n\n\ncollection_relation\n\n\nurl\n\n\npagination_param\n (name of the parameter indicating the current page of results)\n\n\npagination_param_type\n (one of \"query\" or \"placeholder\")\n\n\n\n\n\n\n\n\nResourceGenerator\n\n\nOnce you have defined the metadata for the various objects you will represent in\nyour API, you can start generating resources.\n\n\nZend\\Expressive\\Hal\\ResourceGenerator\n has the following constructor:\n\n\npublic function __construct(\n    Zend\\Expressive\\Hal\\Metadata\\MetadataMap $metadataMap,\n    Psr\\Container\\ContainerInterface $hydrators,\n    Zend\\Expressive\\Hal\\LinkGenerator $linkGenerator\n) {\n\n\n\nWe described the \nMetadataMap\n in the previous section, and the \nLinkGenerator\n\nin the \nprevious chapter\n.\n\n\nHydrators are defind in the \nzend-hydrator component\n,\nand are objects which can \nhdyrate\n associative arrays to object instances and\n\nextract\n associative arrays from object instances. Generally speaking, the\n\n$hydrators\n instance may be any PSR-11 container, but you will generally want\nto use the \nZend\\Hydrator\\HydratorPluginManager\n.\n\n\nOnce you have your instance created, you can start generating resources:\n\n\n$resource = $resourceGenerator->fromObject($book, $request);\n\n\n\n(Where \n$request\n is a \nPsr\\Http\\Message\\ServerRequestInterface\n instance; the\ninstance is passed along to the \nLinkGenerator\n in order to generate route-based\nURIs for \nLink\n instances.)",
            "title": "Generating Resources"
        },
        {
            "location": "/resource-generator/#generating-resources-from-php-objects",
            "text": "In the previous chapter,  we discussed links and resources .\nThe primitive objects allow us to create representations easily, but do not\nanswer one critical question: how can we create resources based on existing PHP\nobject types?  To answer that question, we provide two related features: metadata, and a\nresource generator.",
            "title": "Generating Resources from PHP Objects"
        },
        {
            "location": "/resource-generator/#metadata",
            "text": "Metadata allows you to detail the requirements for generating a HAL\nrepresentation of a PHP object. Metadata might include:   The PHP class name to represent.  A URI to use for the generated resource's self relational link.  Alternately, routing information to use with the  LinkGenerator .  A zend-hydrator extractor to use to serialize the object to a representation.  Whether or not the resource is a collection, and, if so, whether pagination is\n  handled as a path parameter or a query string argument, the name of the\n  parameter, etc.   All metadata types inherit from  Zend\\Expressive\\Hal\\Metadata\\AbstractMetadata ,\nwhich defines a single method,  getClass() , for retrieving the name of the PHP\nclass to represent; all metadata are expected to inherit from this class.  The component also provides four concrete metadata types, requiring the\nfollowing information:   Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata :  string  $class  string  $collectionRelation  string  $route  string  $paginationParam = 'page'  (name of the parameter indicating the\n  current page of results)  string  $paginationParamType = self::TYPE_QUERY  (one of \"query\" or \"placeholder\")  array  $routeParams = []  (associative array of substitutions to use with\n  the designated route)  array  $queryStringArguments = []  (associative array of query string\n  arguments to include in the generated URI)    Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata :  string  $class  string  $route  string  $extractor  (string service name of the zend-hydrator hydrator to\n  use for extracting data from the instance)  string  $resourceIdentifier = 'id'  (name of the property uniquely\n  identifying the resource)  string  $routeIdentifierPlaceholder = 'id'  (name of the routing parameter\n  that maps to the resource identifier)  array  $routeParams = []  (associative array of additional routing\n  parameters to substitute when generating the URI)    Zend\\Expressive\\Hal\\Metadata\\UrlBasedCollectionMetadata :  string  $class  string  $collectionRelation  string  $url  string  $paginationParam = 'page'  (name of the parameter indicating the\n  current page of results)  string  $paginationParamType = self::TYPE_QUERY  (one of \"query\" or \"placeholder\")    Zend\\Expressive\\Hal\\Metadata\\UrlBasedResourceMetadata  string  $class  string  $url  string  $extractor  (string service name of the zend-hydrator hydrator to\n    use for extracting data from the instance)     We aggregate metadata in a  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  instance:  $bookMetadata = new RouteBasedResourceMetadata(\n    Book::class,\n    'book',\n    ObjectPropertyHydrator::class\n);\n$booksMetadata = new RouteBasedCollectionMetadata(\n    BookCollection::class,\n    'book',\n    'books',\n);\n\n$metadataMap = new MetadataMap();\n$metadataMap->add($bookMetadata);\n$metadataMap->add($booksMetadata);",
            "title": "Metadata"
        },
        {
            "location": "/resource-generator/#configuration-based-metadata",
            "text": "To automate generation of the  MetadataMap , we provide Zend\\Expressive\\Hal\\Metadata\\MetadataMapFactory . This factory may be used with any PSR-11  container. It utilizes the  config \nservice, and pulls its configuration from a key named after the Zend\\Expressive\\Hal\\Metadata\\MetadataMap  class.  Each item in the map will be an associative array. The member  __class__  will\ndescribe which metadata class to create, and the remaining properties will then\nbe used to generate an instance. As an example, the above could be configured as\nfollows:  use Api\\Books\\Book;\nuse Api\\Books\\BookCollection;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata;\nuse Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata;\nuse Zend\\Hydrator\\ObjectProperty;\n\nreturn [\n    'Zend\\Expressive\\Hal\\Metadata\\MetadataMap' => [\n        [\n            '__class__' => RouteBasedResourceMetadata::class,\n            'resource_class' => Book::class,\n            'route' => 'book',\n            'extractor' => ObjectProperty::class,\n        ],\n        [\n            '__class__' => RouteBasedCollectionMetadata::class,\n            'collection_class' => BookCollection::class,\n            'collection_relation' => 'book',\n            'route' => 'books',\n        ],\n    ],\n];  The rest of the parameters follow underscore delimiter naming convention:   RouteBasedResourceMetadata::class  resource_identifier  (name of the property uniquely identifying the resource)  route_identifier_placeholder  (name of the routing parameter that maps to the resource identifier)  route_params  (associative array of substitutions to use with the designated route)    RouteBasedCollectionMetadata::class  pagination_param   (name of the parameter indicating the current page of results)  pagination_param_type  (one of \"query\" or \"placeholder\")  route_params  (associative array of substitutions to use with the designated route)  query_string_arguments  (associative array of additional routing parameters to substitute when generating the URI)    UrlBasedResourceMetadata::class  resource_class  url  extractor    UrlBasedCollectionMetadata::class  collection_class  collection_relation  url  pagination_param  (name of the parameter indicating the current page of results)  pagination_param_type  (one of \"query\" or \"placeholder\")",
            "title": "Configuration-based metadata"
        },
        {
            "location": "/resource-generator/#resourcegenerator",
            "text": "Once you have defined the metadata for the various objects you will represent in\nyour API, you can start generating resources.  Zend\\Expressive\\Hal\\ResourceGenerator  has the following constructor:  public function __construct(\n    Zend\\Expressive\\Hal\\Metadata\\MetadataMap $metadataMap,\n    Psr\\Container\\ContainerInterface $hydrators,\n    Zend\\Expressive\\Hal\\LinkGenerator $linkGenerator\n) {  We described the  MetadataMap  in the previous section, and the  LinkGenerator \nin the  previous chapter .  Hydrators are defind in the  zend-hydrator component ,\nand are objects which can  hdyrate  associative arrays to object instances and extract  associative arrays from object instances. Generally speaking, the $hydrators  instance may be any PSR-11 container, but you will generally want\nto use the  Zend\\Hydrator\\HydratorPluginManager .  Once you have your instance created, you can start generating resources:  $resource = $resourceGenerator->fromObject($book, $request);  (Where  $request  is a  Psr\\Http\\Message\\ServerRequestInterface  instance; the\ninstance is passed along to the  LinkGenerator  in order to generate route-based\nURIs for  Link  instances.)",
            "title": "ResourceGenerator"
        },
        {
            "location": "/cookbook/generating-custom-resources/",
            "text": "Generating custom resources\n\n\nThe \nResourceGenerator\n allows composing \nZend\\Expressive\\Hal\\ResourceGenerator\\StrategyInterface\n\ninstances. The \nStrategyInterface\n defines the following:\n\n\nnamespace Zend\\Expressive\\Hal\\ResourceGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Hal\\HalResource;\nuse Zend\\Expressive\\Hal\\Metadata;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\ninterface StrategyInterface\n{\n    /**\n     * @param object $instance Instance from which to create Resource.\n     * @throws Exception\\UnexpectedMetadataTypeException for metadata types the\n     *     strategy cannot handle.\n     */\n    public function createResource(\n        $instance,\n        Metadata\\AbstractMetadata $metadata,\n        ResourceGenerator $resourceGenerator,\n        ServerRequestInterface $request\n    ) : HalResource;\n}\n\n\n\nWhen you register a strategy, you will map a metadata type to the strategy; the\n\nResourceGenerator\n will then call your strategy whenever it encounteres\nmetadata of that type.\n\n\n$resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class);\n\n// or:\n$resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance);\n\n\n\nYou can also add your strategies via the configuration:\n\n\nreturn [\n    'zend-expressive-hal' => [\n        'resource-generator' => [\n            'strategies' => [\n                CustomMetadata::class => CustomStrategy::class,\n            ],\n        ],\n    ],\n];\n\n\n\nIf a strategy already is mapped for the given metadata type, this method will\noverride it.\n\n\nTo facilitate common operations, this library provides two traits,\n\nZend\\Expressive\\Hal\\ResourceGenerator\\ExtractCollectionTrait\n and\n\nZend\\Expressive\\Hal\\ResourceGenerator\\ExtractInstanceTrait\n; inspect these if you\ndecide to write your own strategies.\n\n\nIn order for the \nMetadataMap\n to be able to use your \nCustomMetadata\n you need to register \na factory (implementing \nZend\\Expressive\\Hal\\Metadata\\MetadataFactoryInterface\n) for it.\nYou can register them via the configuration:\n\n\nreturn [\n    'zend-expressive-hal' => [\n        'metadata-factories' => [\n            CustomMetadata::class => CustomMetadataFactory::class,\n        ],\n    ],\n];",
            "title": "Custom Resources"
        },
        {
            "location": "/cookbook/generating-custom-resources/#generating-custom-resources",
            "text": "The  ResourceGenerator  allows composing  Zend\\Expressive\\Hal\\ResourceGenerator\\StrategyInterface \ninstances. The  StrategyInterface  defines the following:  namespace Zend\\Expressive\\Hal\\ResourceGenerator;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Hal\\HalResource;\nuse Zend\\Expressive\\Hal\\Metadata;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\ninterface StrategyInterface\n{\n    /**\n     * @param object $instance Instance from which to create Resource.\n     * @throws Exception\\UnexpectedMetadataTypeException for metadata types the\n     *     strategy cannot handle.\n     */\n    public function createResource(\n        $instance,\n        Metadata\\AbstractMetadata $metadata,\n        ResourceGenerator $resourceGenerator,\n        ServerRequestInterface $request\n    ) : HalResource;\n}  When you register a strategy, you will map a metadata type to the strategy; the ResourceGenerator  will then call your strategy whenever it encounteres\nmetadata of that type.  $resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class);\n\n// or:\n$resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance);  You can also add your strategies via the configuration:  return [\n    'zend-expressive-hal' => [\n        'resource-generator' => [\n            'strategies' => [\n                CustomMetadata::class => CustomStrategy::class,\n            ],\n        ],\n    ],\n];  If a strategy already is mapped for the given metadata type, this method will\noverride it.  To facilitate common operations, this library provides two traits, Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractCollectionTrait  and Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractInstanceTrait ; inspect these if you\ndecide to write your own strategies.  In order for the  MetadataMap  to be able to use your  CustomMetadata  you need to register \na factory (implementing  Zend\\Expressive\\Hal\\Metadata\\MetadataFactoryInterface ) for it.\nYou can register them via the configuration:  return [\n    'zend-expressive-hal' => [\n        'metadata-factories' => [\n            CustomMetadata::class => CustomMetadataFactory::class,\n        ],\n    ],\n];",
            "title": "Generating custom resources"
        },
        {
            "location": "/representations/",
            "text": "Generating Representations\n\n\nThis component provides two renderers, one each for creating JSON and XML\npayloads.\n\n\nAdditionally, as noted in the \nintroduction\n examples, this component\nprovides \nZend\\Expressive\\Hal\\HalResponseFactory\n for generating a\n\nPSR-7\n response containing the HAL\nrepresentation. This chapter dives into that with more detail.\n\n\nRenderers\n\n\nAll renderers implement \nZend\\Expressive\\Hal\\Renderer\\RendererInterface\n:\n\n\nnamespace Zend\\Expressive\\Hal\\Renderer;\n\nuse Zend\\Expressive\\Hal\\HalResource;\n\ninterface RendererInterface\n{\n    public function render(HalResource $resource) : string;\n}\n\n\n\nTwo implementations are provided, \nZend\\Expressive\\Hal\\Renderer\\JsonRenderer\n and\n\nZend\\Expressive\\Hal\\Renderer\\XmlRenderer\n\n\nJsonRenderer\n\n\nThe \nJsonRenderer\n constructor allows you to specify a bitmask of flags for use\nwith \njson_encode()\n. By default, if none are provided, it uses the value of\n\nJsonRenderer::DEFAULT_JSON_FLAGS\n, which evaluates to:\n\n\nJSON_UNESCAPED_SLASHES\n| JSON_UNESCAPED_UNICODE\n| JSON_PRESERVE_ZERO_FRACTION\n\n\n\nWhen your application is in \"debug\" mode, it also adds the \nJSON_PRETTY_PRINT\n\nflag to the default list, in order to provide human-readable JSON output.\n\n\nXmlRenderer\n\n\nThe \nXmlRenderer\n produces XML representations of HAL resources. It has no\nconstructor arguments at this time.\n\n\nHalResponseFactory\n\n\nHalResponseFactory\n generates a PSR-7 response containing a representation of\nthe provided \nHalResource\n instance. In order to keep the component agnostic of\nPSR-7 implementation, \nHalResponseFactory\n itself composes a callable factory\ncapable of producing an empty PSR-7 response.\n\n\nAs an example:\n\n\nuse Slim\\Http\\Response;\nuse Slim\\Http\\Stream;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\n\n$factory = new HalResponseFactory(\n    function () {\n        return new Response();\n    }\n);\n\n\n\nAdditionally, the \nHalResponseFactory\n constructor can accept the following\narguments, with the described defaults if none is provided:\n\n\n\n\nA \nJsonRenderer\n instance is created if none is provided.\n\n\nAn \nXmlRenderer\n instance is created if none is provided.\n\n\n\n\nWe provide a \nPSR-11\n compatible factory for\ngenerating the \nHalResponseFactory\n, described in \nthe factories\nchapter\n.\n\n\nUsing the factory\n\n\nThe factory exposes one method:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Hal\\HalResource;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    HalResource $resource,\n    string $mediaType = self::DEFAULT_CONTENT_TYPE\n) : ResponseInterface {\n\n\n\nGenerally speaking, you'll pass the current request instance, and the resource\nfor which you want to generate a response, and the factory will return a\nresponse based on its response prototype, with the following:\n\n\n\n\nA \nContent-Type\n header with the base media type of \napplication/hal\n.\n\n\nA message body containing the representation.\n\n\n\n\nThe request instance is used to determine what representation to create, based\non the \nAccept\n header. If it matches a JSON media type, a JSON representation\nis created, and the \nContent-Type\n will be appended with \n+json\n; for XML, an\nXML representation is created, and the \nContent-Type\n will be appended with\n\n+xml\n. If no media type is matched, XML is generated.\n\n\nOne practice often used is to provide a \ncustom media type\n for your\nrepresentations. While they will still be HAL, this allows you to document the\nspecific structure of your resources, and potentially even validate them against\nJSON schema.\n\n\nTo do this, pass the media type when creating the response:\n\n\n$response = $factory->createResponse(\n    $request,\n    $resource,\n    'application/vnd.book'\n);\n\n\n\nDo not\n pass the format (e.g., \n+json\n, \n+xml\n) when doing so; the factory will\nappend the appropriate one based on content negotiation.\n\n\nForcing collections for relations\n\n\nHAL allows links and embedded resources to be represented as:\n\n\n\n\na single object\n\n\nan array of objects of the same type\n\n\n\n\nInternally, this package checks to see if only one of the item exists, and, if\nso, it will render it by itself. However, there are times you may want to force\nan array representation. As an example, if your resource models a car, and you\nhave a \nwheels\n relation, it would not make sense to return a single wheel, even\nif that's all the car currently has associated with it.\n\n\nTo accommodate this, we provide two features.\n\n\nFor links, you may pass a special attribute, \nZend\\Expressive\\Hal\\Link::AS_COLLECTION\n,\nwith a boolean value of \ntrue\n; when encountered, this will then be rendered as\nan array of links, even if only one link for that relation is present.\n\n\n$link = new Link(\n    'wheels',\n    '/api/car/XXXX-YYYY-ZZZZ/wheels/111',\n    false,\n    [Link::AS_COLLECTION => true]\n);\n\n$resource = $resource->withLink($link);\n\n\n\nIn the above, you will then get the following within your representation:\n\n\n\"_links\": {\n  \"wheels\": [\n    {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"}\n  ]\n}\n\n\n\nTo force an embedded resource to be rendered within an array, you have two\noptions.\n\n\nFirst, and simplest, pass the resource within an array when calling\n\nwithElement()\n, \nembed()\n, or passing data to the constructor:\n\n\n// Constructor:\n$resource = new HalResource(['wheels' => [$wheel]]);\n\n// withElement():\n$resource = $resource->withElement('wheels', [$wheel]);\n\n// embed():\n$resource = $resource->embed('wheels', [$wheel]);\n\n\n\nAlternately, you can call the \nHalResource::embed\n method with only the\nresource, passing the method a third argument, a flag indicating whether or not\nto force an array:\n\n\n$resource = $resource->embed('wheels', $wheel, true);\n\n\n\nIn each of these cases, assuming no other wheels were provided to the final\nresource, you might get a representation such as the following:\n\n\n\"_embedded\": {\n  \"wheels\": [\n    {\n      \"_links\" => {\"self\": {\"href\": \"...\"}}\n      \"id\": \"...\"\n    },\n  ]\n}",
            "title": "Representations"
        },
        {
            "location": "/representations/#generating-representations",
            "text": "This component provides two renderers, one each for creating JSON and XML\npayloads.  Additionally, as noted in the  introduction  examples, this component\nprovides  Zend\\Expressive\\Hal\\HalResponseFactory  for generating a PSR-7  response containing the HAL\nrepresentation. This chapter dives into that with more detail.",
            "title": "Generating Representations"
        },
        {
            "location": "/representations/#renderers",
            "text": "All renderers implement  Zend\\Expressive\\Hal\\Renderer\\RendererInterface :  namespace Zend\\Expressive\\Hal\\Renderer;\n\nuse Zend\\Expressive\\Hal\\HalResource;\n\ninterface RendererInterface\n{\n    public function render(HalResource $resource) : string;\n}  Two implementations are provided,  Zend\\Expressive\\Hal\\Renderer\\JsonRenderer  and Zend\\Expressive\\Hal\\Renderer\\XmlRenderer",
            "title": "Renderers"
        },
        {
            "location": "/representations/#jsonrenderer",
            "text": "The  JsonRenderer  constructor allows you to specify a bitmask of flags for use\nwith  json_encode() . By default, if none are provided, it uses the value of JsonRenderer::DEFAULT_JSON_FLAGS , which evaluates to:  JSON_UNESCAPED_SLASHES\n| JSON_UNESCAPED_UNICODE\n| JSON_PRESERVE_ZERO_FRACTION  When your application is in \"debug\" mode, it also adds the  JSON_PRETTY_PRINT \nflag to the default list, in order to provide human-readable JSON output.",
            "title": "JsonRenderer"
        },
        {
            "location": "/representations/#xmlrenderer",
            "text": "The  XmlRenderer  produces XML representations of HAL resources. It has no\nconstructor arguments at this time.",
            "title": "XmlRenderer"
        },
        {
            "location": "/representations/#halresponsefactory",
            "text": "HalResponseFactory  generates a PSR-7 response containing a representation of\nthe provided  HalResource  instance. In order to keep the component agnostic of\nPSR-7 implementation,  HalResponseFactory  itself composes a callable factory\ncapable of producing an empty PSR-7 response.  As an example:  use Slim\\Http\\Response;\nuse Slim\\Http\\Stream;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\n\n$factory = new HalResponseFactory(\n    function () {\n        return new Response();\n    }\n);  Additionally, the  HalResponseFactory  constructor can accept the following\narguments, with the described defaults if none is provided:   A  JsonRenderer  instance is created if none is provided.  An  XmlRenderer  instance is created if none is provided.   We provide a  PSR-11  compatible factory for\ngenerating the  HalResponseFactory , described in  the factories\nchapter .",
            "title": "HalResponseFactory"
        },
        {
            "location": "/representations/#using-the-factory",
            "text": "The factory exposes one method:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Hal\\HalResource;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    HalResource $resource,\n    string $mediaType = self::DEFAULT_CONTENT_TYPE\n) : ResponseInterface {  Generally speaking, you'll pass the current request instance, and the resource\nfor which you want to generate a response, and the factory will return a\nresponse based on its response prototype, with the following:   A  Content-Type  header with the base media type of  application/hal .  A message body containing the representation.   The request instance is used to determine what representation to create, based\non the  Accept  header. If it matches a JSON media type, a JSON representation\nis created, and the  Content-Type  will be appended with  +json ; for XML, an\nXML representation is created, and the  Content-Type  will be appended with +xml . If no media type is matched, XML is generated.  One practice often used is to provide a  custom media type  for your\nrepresentations. While they will still be HAL, this allows you to document the\nspecific structure of your resources, and potentially even validate them against\nJSON schema.  To do this, pass the media type when creating the response:  $response = $factory->createResponse(\n    $request,\n    $resource,\n    'application/vnd.book'\n);  Do not  pass the format (e.g.,  +json ,  +xml ) when doing so; the factory will\nappend the appropriate one based on content negotiation.",
            "title": "Using the factory"
        },
        {
            "location": "/representations/#forcing-collections-for-relations",
            "text": "HAL allows links and embedded resources to be represented as:   a single object  an array of objects of the same type   Internally, this package checks to see if only one of the item exists, and, if\nso, it will render it by itself. However, there are times you may want to force\nan array representation. As an example, if your resource models a car, and you\nhave a  wheels  relation, it would not make sense to return a single wheel, even\nif that's all the car currently has associated with it.  To accommodate this, we provide two features.  For links, you may pass a special attribute,  Zend\\Expressive\\Hal\\Link::AS_COLLECTION ,\nwith a boolean value of  true ; when encountered, this will then be rendered as\nan array of links, even if only one link for that relation is present.  $link = new Link(\n    'wheels',\n    '/api/car/XXXX-YYYY-ZZZZ/wheels/111',\n    false,\n    [Link::AS_COLLECTION => true]\n);\n\n$resource = $resource->withLink($link);  In the above, you will then get the following within your representation:  \"_links\": {\n  \"wheels\": [\n    {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"}\n  ]\n}  To force an embedded resource to be rendered within an array, you have two\noptions.  First, and simplest, pass the resource within an array when calling withElement() ,  embed() , or passing data to the constructor:  // Constructor:\n$resource = new HalResource(['wheels' => [$wheel]]);\n\n// withElement():\n$resource = $resource->withElement('wheels', [$wheel]);\n\n// embed():\n$resource = $resource->embed('wheels', [$wheel]);  Alternately, you can call the  HalResource::embed  method with only the\nresource, passing the method a third argument, a flag indicating whether or not\nto force an array:  $resource = $resource->embed('wheels', $wheel, true);  In each of these cases, assuming no other wheels were provided to the final\nresource, you might get a representation such as the following:  \"_embedded\": {\n  \"wheels\": [\n    {\n      \"_links\" => {\"self\": {\"href\": \"...\"}}\n      \"id\": \"...\"\n    },\n  ]\n}",
            "title": "Forcing collections for relations"
        },
        {
            "location": "/factories/",
            "text": "Provided factories\n\n\nThis component provides a number of factories for use with\n\nPSR-11\n, in order to generate fully\nconfigured instances for your use.\n\n\nZend\\Expressive\\Hal\\HalResponseFactoryFactory\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\HalResponseFactory\n\n\nGenerates instance of: \nZend\\Expressive\\Hal\\HalResponseFactory\n\n\nDepends on:\n\n\nPsr\\Http\\Message\\ResponseInterface\n service. The service must resolve to\n  a PHP callable capable of generating a \nPSR-7\n\n  \nResponseInterface\n instance; it must not resolve to a \nResponseInterface\n\n  instance directly. This service is \nrequired\n, and must be supplied by\n  the application. If you are using with zend-expressive v3 and above, the\n  service will already be registered.\n\n\nZend\\Expressive\\Hal\\Renderer\\JsonRenderer\n service. If the service is not\n  present, it instantiates an instance itself.\n\n\nZend\\Expressive\\Hal\\Renderer\\XmlRenderer\n service. If the service is not\n  present, it instantiates an instance itself.\n\n\n\n\n\n\n\n\nZend\\Expressive\\Hal\\LinkGeneratorFactory\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\LinkGenerator\n\n\nGenerates instance of: \nZend\\Expressive\\Hal\\LinkGenerator\n\n\nDepends on:\n\n\nZend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface\n service\n\n\n\n\n\n\n\n\nSince version 1.1.0, this factory allows an optional constructor argument,\n\n$urlGeneratorServiceName\n. It defaults to\n\nZend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface\n,\nbut you may specify an alternate service if desired. This may be useful, for\ninstance, when using an alternate router in a path-segregated middleware\npipeline, which would necessitate a different \nUrlHelper\n instance, and an\nalternate URL generator that consumes it.\n\n\nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\nGenerates instance of: \nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\nDepends on:\n\n\nzendframework/zend-expressive-helpers\n package\n\n\nZend\\Expressive\\Helper\\UrlHelper\n service\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n service (optional; if not provided,\n  URIs will be generated without authority information)\n\n\n\n\n\n\n\n\nSince version 1.1.0, this factory allows an optional constructor argument, \n$urlHelperServiceName\n.\nIt defaults to \nZend\\Expressive\\Helper\\UrlHelper\n, but you may specify an\nalternate service if desired. This may be useful, for instance, when using an\nalternate router in a path-segregated middleware pipeline, which would\nnecessitate a different \nUrlHelper\n instance.\n\n\nZend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface\n\n\nAliased to service: \nZend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator\n\n\n\n\nYou can either define an alternate alias, or map the \nUrlGeneratorInterface\n service\ndirectly to a factory that will return a valid instance.\n\n\nZend\\Expressive\\Hal\\Metadata\\MetadataMapFactory\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n\n\nGenerates instance of: \nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n\n\nDepends on:\n\n\nconfig\n service; if not present, will use an empty array\n\n\n\n\n\n\n\n\nThis service uses the \nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n key of the \nconfig\n service in\norder to configure and return a \nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n instance. It expects\nthat value to be an array of elements, each with the following structure:\n\n\n[\n    '__class__' => 'Fully qualified class name of an AbstractMetadata type',\n    // additional key/value pairs as required by the metadata type.\n]\n\n\n\nThe additional pairs are as follows:\n\n\n\n\nFor \nUrlBasedResourceMetadata\n:\n\n\nresource_class\n: the resource class the metadata describes.\n\n\nurl\n: the URL to use when generating a self-relational link for the\n  resource.\n\n\nextractor\n: the extractor/hydrator service to use to extract resource\n  data.\n\n\n\n\n\n\nFor \nUrlBasedCollectionMetadata\n:\n\n\ncollection_class\n: the collection class the metadata describes.\n\n\ncollection_relation\n: the embedded relation for the collection in the\n  generated resource.\n\n\nurl\n: the URL to use when generating a self-relational link for the\n  collection resource.\n\n\npagination_param\n: the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".\n\n\npagination_param_type\n: whether the pagination parameter is a query string\n  or path placeholder; use either \nAbstractCollectionMetadata::TYPE_QUERY\n\n  (\"query\") or \nAbstractCollectionMetadata::TYPE_PLACEHOLDER\n (\"placeholder\");\n  default is \"query\".\n\n\n\n\n\n\nFor \nRouteBasedResourceMetadata\n:\n\n\nresource_class\n: the resource class the metadata describes.\n\n\nroute\n: the route to use when generating a self relational link for the\n  resource.\n\n\nextractor\n: the extractor/hydrator service to use to extract resource\n  data.\n\n\nresource_identifier\n: what property in the resource represents its\n  identifier; defaults to \"id\".\n\n\nroute_identifier_placeholder\n: what placeholder in the route string\n  represents the resource identifier; defaults to \"id\".\n\n\nroute_params\n: an array of additional routing parameters to use when\n  generating the self relational link for the resource.\n\n\n\n\n\n\nFor \nRouteBasedCollectionMetadata\n:\n\n\ncollection_class\n: the collection class the metadata describes.\n\n\ncollection_relation\n: the embedded relation for the collection in the\n  generated resource.\n\n\nroute\n: the route to use when generating a self relational link for the\n  collection resource.\n\n\npagination_param\n: the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".\n\n\npagination_param_type\n: whether the pagination parameter is a query string\n  or path placeholder; use either \nAbstractCollectionMetadata::TYPE_QUERY\n\n  (\"query\") or \nAbstractCollectionMetadata::TYPE_PLACEHOLDER\n (\"placeholder\");\n  default is \"query\".\n\n\nroute_params\n: an array of additional routing parameters to use when\n  generating the self relational link for the collection resource. Defaults\n  to an empty array.\n\n\nquery_string_arguments\n: an array of query string parameters to include\n  when generating the self relational link for the collection resource.\n  Defaults to an empty array.\n\n\n\n\n\n\n\n\nIf you have created custom metadata types, you can extend this class to\nsupport them. Create \ncreate<type>(array $metadata)\n methods for each\ntype you wish to support, where \n<type>\n is your custom class name, minus\nthe namespace.\n\n\n\n\nLimitation\n\n\nThere is a \nknown limitation\n\nwith zend-router when using routes with optional parameters (e.g., \n/books[/:id]\n,\nwhere \n:id\n is optional). In such cases, if no matching parameter is provided\n(such as when generating a URI without an \n:id\n), the router will raise an\nexception due to the missing parameter.\n\n\nIf you encounter this issue, create separate routing entries for each optional\nparameter. See the issue for a comprehensive example.\n\n\n\n\nZend\\Expressive\\Hal\\ResourceGeneratorFactory\n\n\n\n\nRegistered as service: \nZend\\Expressive\\Hal\\ResourceGenerator\n\n\nGenerates instance of: \nZend\\Expressive\\Hal\\ResourceGenerator\n\n\nDepends on:\n\n\nZend\\Expressive\\Hal\\Metadata\\MetadataMap\n service\n\n\nZend\\Hydrator\\HydratorPluginManager\n service\n\n\nZend\\Expressive\\Hal\\LinkGenerator\n service\n\n\n\n\n\n\n\n\nIf you wish to use a container implementation other than the\n\nZend\\Hydrator\\HydratorPluginManager\n, either register it under that service\nname, or create an alternate factory.\n\n\nSince version 1.1.0, this factory allows an optional constructor argument, \n$linkGeneratorServiceName\n.\nIt defaults to \nZend\\Expressive\\Hal\\LinkGenerator\n, but you may specify an\nalternate service if desired. This may be useful, for instance, when using an\nalternate router in a path-segregated middleware pipeline, which would\nnecessitate a different \nUrlHelper\n instance, an alternate URL generator that\nconsumes it, and an alternate \nLinkGenerator\n consuming the URL generator.",
            "title": "Factories"
        },
        {
            "location": "/factories/#provided-factories",
            "text": "This component provides a number of factories for use with PSR-11 , in order to generate fully\nconfigured instances for your use.",
            "title": "Provided factories"
        },
        {
            "location": "/factories/#zendexpressivehalhalresponsefactoryfactory",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\HalResponseFactory  Generates instance of:  Zend\\Expressive\\Hal\\HalResponseFactory  Depends on:  Psr\\Http\\Message\\ResponseInterface  service. The service must resolve to\n  a PHP callable capable of generating a  PSR-7 \n   ResponseInterface  instance; it must not resolve to a  ResponseInterface \n  instance directly. This service is  required , and must be supplied by\n  the application. If you are using with zend-expressive v3 and above, the\n  service will already be registered.  Zend\\Expressive\\Hal\\Renderer\\JsonRenderer  service. If the service is not\n  present, it instantiates an instance itself.  Zend\\Expressive\\Hal\\Renderer\\XmlRenderer  service. If the service is not\n  present, it instantiates an instance itself.",
            "title": "Zend\\Expressive\\Hal\\HalResponseFactoryFactory"
        },
        {
            "location": "/factories/#zendexpressivehallinkgeneratorfactory",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\LinkGenerator  Generates instance of:  Zend\\Expressive\\Hal\\LinkGenerator  Depends on:  Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface  service     Since version 1.1.0, this factory allows an optional constructor argument, $urlGeneratorServiceName . It defaults to Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface ,\nbut you may specify an alternate service if desired. This may be useful, for\ninstance, when using an alternate router in a path-segregated middleware\npipeline, which would necessitate a different  UrlHelper  instance, and an\nalternate URL generator that consumes it.",
            "title": "Zend\\Expressive\\Hal\\LinkGeneratorFactory"
        },
        {
            "location": "/factories/#zendexpressivehallinkgeneratorexpressiveurlgeneratorfactory",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator  Generates instance of:  Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator  Depends on:  zendframework/zend-expressive-helpers  package  Zend\\Expressive\\Helper\\UrlHelper  service  Zend\\Expressive\\Helper\\ServerUrlHelper  service (optional; if not provided,\n  URIs will be generated without authority information)     Since version 1.1.0, this factory allows an optional constructor argument,  $urlHelperServiceName .\nIt defaults to  Zend\\Expressive\\Helper\\UrlHelper , but you may specify an\nalternate service if desired. This may be useful, for instance, when using an\nalternate router in a path-segregated middleware pipeline, which would\nnecessitate a different  UrlHelper  instance.",
            "title": "Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory"
        },
        {
            "location": "/factories/#zendexpressivehallinkgeneratorurlgeneratorinterface",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface  Aliased to service:  Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator   You can either define an alternate alias, or map the  UrlGeneratorInterface  service\ndirectly to a factory that will return a valid instance.",
            "title": "Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface"
        },
        {
            "location": "/factories/#zendexpressivehalmetadatametadatamapfactory",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  Generates instance of:  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  Depends on:  config  service; if not present, will use an empty array     This service uses the  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  key of the  config  service in\norder to configure and return a  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  instance. It expects\nthat value to be an array of elements, each with the following structure:  [\n    '__class__' => 'Fully qualified class name of an AbstractMetadata type',\n    // additional key/value pairs as required by the metadata type.\n]  The additional pairs are as follows:   For  UrlBasedResourceMetadata :  resource_class : the resource class the metadata describes.  url : the URL to use when generating a self-relational link for the\n  resource.  extractor : the extractor/hydrator service to use to extract resource\n  data.    For  UrlBasedCollectionMetadata :  collection_class : the collection class the metadata describes.  collection_relation : the embedded relation for the collection in the\n  generated resource.  url : the URL to use when generating a self-relational link for the\n  collection resource.  pagination_param : the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".  pagination_param_type : whether the pagination parameter is a query string\n  or path placeholder; use either  AbstractCollectionMetadata::TYPE_QUERY \n  (\"query\") or  AbstractCollectionMetadata::TYPE_PLACEHOLDER  (\"placeholder\");\n  default is \"query\".    For  RouteBasedResourceMetadata :  resource_class : the resource class the metadata describes.  route : the route to use when generating a self relational link for the\n  resource.  extractor : the extractor/hydrator service to use to extract resource\n  data.  resource_identifier : what property in the resource represents its\n  identifier; defaults to \"id\".  route_identifier_placeholder : what placeholder in the route string\n  represents the resource identifier; defaults to \"id\".  route_params : an array of additional routing parameters to use when\n  generating the self relational link for the resource.    For  RouteBasedCollectionMetadata :  collection_class : the collection class the metadata describes.  collection_relation : the embedded relation for the collection in the\n  generated resource.  route : the route to use when generating a self relational link for the\n  collection resource.  pagination_param : the name of the parameter indicating what page of data\n  is present. Defaults to \"page\".  pagination_param_type : whether the pagination parameter is a query string\n  or path placeholder; use either  AbstractCollectionMetadata::TYPE_QUERY \n  (\"query\") or  AbstractCollectionMetadata::TYPE_PLACEHOLDER  (\"placeholder\");\n  default is \"query\".  route_params : an array of additional routing parameters to use when\n  generating the self relational link for the collection resource. Defaults\n  to an empty array.  query_string_arguments : an array of query string parameters to include\n  when generating the self relational link for the collection resource.\n  Defaults to an empty array.     If you have created custom metadata types, you can extend this class to\nsupport them. Create  create<type>(array $metadata)  methods for each\ntype you wish to support, where  <type>  is your custom class name, minus\nthe namespace.",
            "title": "Zend\\Expressive\\Hal\\Metadata\\MetadataMapFactory"
        },
        {
            "location": "/factories/#limitation",
            "text": "There is a  known limitation \nwith zend-router when using routes with optional parameters (e.g.,  /books[/:id] ,\nwhere  :id  is optional). In such cases, if no matching parameter is provided\n(such as when generating a URI without an  :id ), the router will raise an\nexception due to the missing parameter.  If you encounter this issue, create separate routing entries for each optional\nparameter. See the issue for a comprehensive example.",
            "title": "Limitation"
        },
        {
            "location": "/factories/#zendexpressivehalresourcegeneratorfactory",
            "text": "Registered as service:  Zend\\Expressive\\Hal\\ResourceGenerator  Generates instance of:  Zend\\Expressive\\Hal\\ResourceGenerator  Depends on:  Zend\\Expressive\\Hal\\Metadata\\MetadataMap  service  Zend\\Hydrator\\HydratorPluginManager  service  Zend\\Expressive\\Hal\\LinkGenerator  service     If you wish to use a container implementation other than the Zend\\Hydrator\\HydratorPluginManager , either register it under that service\nname, or create an alternate factory.  Since version 1.1.0, this factory allows an optional constructor argument,  $linkGeneratorServiceName .\nIt defaults to  Zend\\Expressive\\Hal\\LinkGenerator , but you may specify an\nalternate service if desired. This may be useful, for instance, when using an\nalternate router in a path-segregated middleware pipeline, which would\nnecessitate a different  UrlHelper  instance, an alternate URL generator that\nconsumes it, and an alternate  LinkGenerator  consuming the URL generator.",
            "title": "Zend\\Expressive\\Hal\\ResourceGeneratorFactory"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/",
            "text": "Generating custom links in middleware and request handlers\n\n\nIn most cases, you can rely on the \nResourceGenerator\n to generate self\nrelational links, and, in the case of paginated collections, pagination links.\n\n\nWhat if you want to generate other links to include in your resources, though?\n\n\nThe \nResourceGenerator\n provides access to the metadata map, hydrators, and link\ngenerator via getter methods:\n\n\n\n\ngetMetadataMap()\n\n\ngetHydrators()\n\n\ngetLinkGenerator()\n\n\n\n\nWe can thus use these in order to generate custom links as needed.\n\n\nCreating a custom link to include in a resource\n\n\nIn our first scenario, we'll create a \"search\" link for a resource.\n\n\nWe'll assume that you have composed a \nResourceGenerator\n instance in your\nmiddleware, and assigned it to the \n$resourceGenerator\n property.\n\n\nThe link we want to generate will look something like\n\n/api/books?query={searchParms}\n, and map to a route named \nbooks\n.\n\n\n$searchLink = $this->resourceGenerator\n    ->getLinkGenerator()\n    ->templatedFromRoute(\n        'search',\n        $request,\n        'books',\n        [],\n        ['query' => '{searchTerms}']\n    );\n\n\n\nYou could then compose it in your resource:\n\n\n$resource = $resource->withLink($searchLink);\n\n\n\nAdding metadata for generated links\n\n\nIn our second scenario, we'll consider a collection endpoint. It might include a\n\nper_page\n query string argument, to allow defining how many results to return\nper page, a \nsort\n argument, and a \nquery\n argument indicating the search\nstring. We know these at \nruntime\n, but not at the time we create our\nconfiguration, so we need to inject them \nafter\n we have our metadata created,\nbut \nbefore\n we generate our resource, so that the pagination links are\ncorrectly generated.\n\n\n$queryParams = $request->getQueryParams();\n$query       = $queryParams['query'] ?? '';\n$perPage     = $queryParams['per_page'] ?? 25;\n$sort        = $queryParams['sort'] ?? '';\n$metadataMap = $this->resourceGenerator->getMetadataMap();\n$metadata    = $metadataMap->get(BookCollection::class);\n\n$metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments();\n\nif ('' !== $query) {\n    $metadataQuery = array_merge($metadataQuery, ['query' => $query]);\n}\n\nif ('' !== $perPage) {\n    $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]);\n}\n\nif ('' !== $sort) {\n    $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]);\n}\n\n$metadata->setQueryStringArguments($metadataQuery);\n\n// ...\n\n$resource = $this->resourceGenerator->fromObject($books, $request);\n\n// Reset query string arguments\n$metadata->setQueryStringArguments($origMetadataQuery);\n\n\n\nThis will lead to links with URIs such as\n\n/api/books?query=Adams&per_page=5&sort=DESC&page=4\n.",
            "title": "Generating Custom Links In Middleware and Request Handlers"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#generating-custom-links-in-middleware-and-request-handlers",
            "text": "In most cases, you can rely on the  ResourceGenerator  to generate self\nrelational links, and, in the case of paginated collections, pagination links.  What if you want to generate other links to include in your resources, though?  The  ResourceGenerator  provides access to the metadata map, hydrators, and link\ngenerator via getter methods:   getMetadataMap()  getHydrators()  getLinkGenerator()   We can thus use these in order to generate custom links as needed.",
            "title": "Generating custom links in middleware and request handlers"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#creating-a-custom-link-to-include-in-a-resource",
            "text": "In our first scenario, we'll create a \"search\" link for a resource.  We'll assume that you have composed a  ResourceGenerator  instance in your\nmiddleware, and assigned it to the  $resourceGenerator  property.  The link we want to generate will look something like /api/books?query={searchParms} , and map to a route named  books .  $searchLink = $this->resourceGenerator\n    ->getLinkGenerator()\n    ->templatedFromRoute(\n        'search',\n        $request,\n        'books',\n        [],\n        ['query' => '{searchTerms}']\n    );  You could then compose it in your resource:  $resource = $resource->withLink($searchLink);",
            "title": "Creating a custom link to include in a resource"
        },
        {
            "location": "/cookbook/generating-custom-links-in-middleware/#adding-metadata-for-generated-links",
            "text": "In our second scenario, we'll consider a collection endpoint. It might include a per_page  query string argument, to allow defining how many results to return\nper page, a  sort  argument, and a  query  argument indicating the search\nstring. We know these at  runtime , but not at the time we create our\nconfiguration, so we need to inject them  after  we have our metadata created,\nbut  before  we generate our resource, so that the pagination links are\ncorrectly generated.  $queryParams = $request->getQueryParams();\n$query       = $queryParams['query'] ?? '';\n$perPage     = $queryParams['per_page'] ?? 25;\n$sort        = $queryParams['sort'] ?? '';\n$metadataMap = $this->resourceGenerator->getMetadataMap();\n$metadata    = $metadataMap->get(BookCollection::class);\n\n$metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments();\n\nif ('' !== $query) {\n    $metadataQuery = array_merge($metadataQuery, ['query' => $query]);\n}\n\nif ('' !== $perPage) {\n    $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]);\n}\n\nif ('' !== $sort) {\n    $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]);\n}\n\n$metadata->setQueryStringArguments($metadataQuery);\n\n// ...\n\n$resource = $this->resourceGenerator->fromObject($books, $request);\n\n// Reset query string arguments\n$metadata->setQueryStringArguments($origMetadataQuery);  This will lead to links with URIs such as /api/books?query=Adams&per_page=5&sort=DESC&page=4 .",
            "title": "Adding metadata for generated links"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/",
            "text": "Using the ResourceGenerator in path-segregated middleware\n\n\n\n\nSince 1.1.0.\n\n\n\n\nYou may want to develop your API as a separate module that you can then drop in\nto an existing application; you may even want to \npath-segregate\n it.\n\n\nIn such cases, you will want to use a different router instance to isolate your routes, which has a\nhuge number of ramifications:\n\n\n\n\nYou'll need separate routing middleware.\n\n\nYou'll need a separate \nUrlHelper\n instance, as well as its related middleware.\n\n\nYou'll need a separate URL generator for HAL that consumes the separate\n  \nUrlHelper\n instance.\n\n\nYou'll need a separate \nLinkGenerator\n for HAL that consumes the separate URL\n  generator.\n\n\nYou'll need a separate \nResourceGenerator\n for HAL that consumes the separate\n  \nLinkGenerator\n.\n\n\n\n\nThis can be accomplished by writing your own factories, but that means a lot of\nextra code, and the potential for it to go out-of-sync with the official\nfactories for these services. What should you do?\n\n\nVirtual services\n\n\nSince version 1.1.0 of this package, and versions 3.1.0 of\nzend-expressive-router and 5.1.0 of zend-expressive-helpers, you can now pass\nadditional constructor arguments to a number of factories to allow varying the\nservice dependencies they look for.\n\n\nIn our example below, we will create an \nApi\n module. This module will have its\nown router, and be segregated in the path \n/api\n; all routes we create will be\nrelative to that path, and not include it in their definitions. The handler we\ncreate will return HAL-JSON, and thus need to generate links using the\nconfigured router and base path.\n\n\nTo begin, we will alter the \nConfigProvider\n for our module to add the\ndefinitions noted below:\n\n\n// in src/Api/ConfigProvider.php:\nnamespace Api;\n\nuse Zend\\Expressive\\Hal\\LinkGeneratorFactory;\nuse Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\ResourceGeneratorFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouterFactory;\n\nclass ConfigProvider\n{\n    public function __invoke() : array\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            MetadataMap::class => $this->getMetadataMap(),\n        ];\n    }\n\n    public function getDependencies() : array\n    {\n        return [\n            'factories' => [\n                // module-specific class name => factory\n                LinkGenerator::class          => new LinkGeneratorFactory(UrlGenerator::class),\n                ResourceGenerator::class      => new ResourceGeneratorFactory(LinkGenerator::class),\n                Router::class                 => FastRouteRouterFactory::class,\n                RouteMiddleware::class        => new RouteMiddlewareFactory(Router::class),\n                UrlHelper::class              => new UrlHelperFactory('/api', Router::class),\n                UrlHelperMiddleware::class    => new UrlHelperMiddlewareFactory(UrlHelper::class),\n                UrlGenerator::class           => new ExpressiveUrlGeneratorFactory(UrlHelper::class),\n\n                // Our handler:\n                CreateBookHandler::class => CreateBookHandlerFactory::class,\n\n                // And our pipeline:\n                Pipeline::class => PipelineFactory::class,\n            ],\n        ];\n    }\n\n    public function getMetadataMap() : array\n    {\n        return [\n            // ...\n        ];\n    }\n}\n\n\n\nNote that the majority of these service names are \nvirtual\n; they do not resolve\nto actual classes. PHP allows usage of the \n::class\n pseudo-constant anywhere,\nand will resolve the value based on the current namespace. This gives us virtual\nservices such as \nApi\\Router\n, \nApi\\UrlHelper\n, etc.\n\n\nAlso note that we are creating factory \ninstances\n. Normally, we recommend not\nusing closures or instances for factories due to potential problems with\nconfiguration caching. Fortunately, we have provided functionality in each of\nthese factories that allows them to be safely cached, retaining the\ncontext-specific configuration required.\n\n\n\n\nWhat about the hard-coded path?\n\n\nYou'll note that the above example hard-codes the base path for the\n\nUrlHelper\n. What if you want to use a different path?\n\n\nYou can override the service in an application-specific configuration under\n\nconfig/autoload/\n, specifying a different path!\n\n\n\\Api\\UrlHelper::class => new UrlHelperFactory('/different/path', \\Api\\Router::class),\n\n\n\n\n\nUsing virtual services with a handler\n\n\nNow let's turn to our \nCreateBookHandler\n. We'll define it as follows:\n\n\n// in src/Api/CreateBookHandler.php:\nnamespace Api;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass CreateBookHandler implements RequestHandlerInterface\n{\n    private $resourceGenerator;\n\n    private $responseFactory;\n\n    public function __construct(ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory)\n    {\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // do some work ...\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $book);\n    }\n}\n\n\n\nThis handler needs a HAL resource generator. More specifically, it needs the one\nspecific to our module. As such, we'll define our factory as follows:\n\n\n// in src/Api/CreateBookHandlerFactory.php:\nnamespace Api;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\n\nclass CreateBookHandlerFactory\n{\n    public function __invoke(ContainerInterface $container) : CreateBookHandler\n    {\n        return new CreateBookHandler(\n            ResourceGenerator::class, // module-specific service name!\n            HalResponseFactory::class\n        );\n    }\n}\n\n\n\nYou can create any number of such handlers for your module; the above\ndemonstrates how and where injection of the alternate resource generator occurs.\n\n\nCreating our pipeline and routes\n\n\nNow we can create our pipeline and routes.\n\n\nGenerally when piping to an application instance, we can specify a class name of\nmiddleware to pipe, or an array of middleware:\n\n\n// in config/pipeline.php:\n$app->pipe('/api', [\n    \\Zend\\ProblemDetails\\ProblemDetailsMiddleware::class,\n    \\Api\\RouteMiddleware::class,     // module-specific routing middleware!\n    ImplicitHeadMiddleware::class,\n    ImplicitOptionsMiddleware::class,\n    MethodNotAllowedMiddleware::class,\n    \\Api\\UrlHelperMiddleware::class, // module-specific URL helper middleware!\n    DispatchMiddleware::class,\n    \\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class,\n]);\n\n\n\nHowever, we have both the pipeline \nand\n routes, and we likely want to indicate\nthe exact behavior of this pipeline. Additionally, we may want to re-use this\npipeline in other applications; pushing this into the application configuration\nmakes that more error-prone.\n\n\nAs such, we will create a factory that generates and returns a\n\nZend\\Stratigility\\MiddlewarePipe\n instance that is fully configured for our\nmodule. As part of this functionality, we will also add our module-specific\nrouting.\n\n\n// In src/Api/PipelineFactory.php:\nnamespace Api;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Router\\Middleware as RouterMiddleware;\nuse Zend\\Expressive\\Router\\RouteCollector;\nuse Zend\\ProblemDetails\\ProblemDetailsMiddleware;\nuse Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass PipelineFactory\n{\n    public function __invoke(ContainerInterface $container) : MiddlewarePipe\n    {\n        $factory = $container->get(MiddlewareFactory::class);\n\n        // First, create our middleware pipeline\n        $pipeline = new MiddlewarePipe();\n        $pipeline->pipe($factory->lazy(ProblemDetailsMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouteMiddleware::class)); // module-specific!\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitHeadMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitOptionsMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\MethodNotAllowedMiddleware::class));\n        $pipeline->pipe($factory->lazy(UrlHelperMiddleware::class)); // module-specific!\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\DispatchMiddleware::class));\n        $pipeline->pipe($factory->lazy(ProblemDetailsNotFoundHandler::class));\n\n        // Second, we'll create our routes\n        $router = $container->get(Router::class); // Retrieve our module-specific router\n        $routes = new RouteCollector($router);    // Create a route collector to simplify routing\n\n        // Start routing:\n        $routes->post('/books', $factory->lazy(CreateBookHandler::class));\n\n        // Return the pipeline now that we're done!\n        return $pipeline;\n    }\n}\n\n\n\nNote that the routing definitions do \nnot\n include the prefix \n/api\n; this is\nbecause that prefix will be stripped when we path-segregate our API middleware\npipeline. All routing will be \nrelative\n to that path.\n\n\nCreating a path-segregated pipeline\n\n\nFinally, we will attach our pipeline to the application, using path segregation:\n\n\n// in config/pipeline.php:\n$app->pipe('/api', \\Api\\Pipeline::class);\n\n\n\nThis statement tells the application to pipe the pipeline returned by our\n\nPipelineFactory\n under the path \n/api\n; that path will be stripped from\nrequests when passed to the underlying middleware.\n\n\nAt this point, we now have a re-usable module, complete with its own routing,\nwith URI generation that will include the base path under which we have\nsegregated the pipeline!",
            "title": "Using the ResourceGenerator in path-segregated middleware"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#using-the-resourcegenerator-in-path-segregated-middleware",
            "text": "Since 1.1.0.   You may want to develop your API as a separate module that you can then drop in\nto an existing application; you may even want to  path-segregate  it.  In such cases, you will want to use a different router instance to isolate your routes, which has a\nhuge number of ramifications:   You'll need separate routing middleware.  You'll need a separate  UrlHelper  instance, as well as its related middleware.  You'll need a separate URL generator for HAL that consumes the separate\n   UrlHelper  instance.  You'll need a separate  LinkGenerator  for HAL that consumes the separate URL\n  generator.  You'll need a separate  ResourceGenerator  for HAL that consumes the separate\n   LinkGenerator .   This can be accomplished by writing your own factories, but that means a lot of\nextra code, and the potential for it to go out-of-sync with the official\nfactories for these services. What should you do?",
            "title": "Using the ResourceGenerator in path-segregated middleware"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#virtual-services",
            "text": "Since version 1.1.0 of this package, and versions 3.1.0 of\nzend-expressive-router and 5.1.0 of zend-expressive-helpers, you can now pass\nadditional constructor arguments to a number of factories to allow varying the\nservice dependencies they look for.  In our example below, we will create an  Api  module. This module will have its\nown router, and be segregated in the path  /api ; all routes we create will be\nrelative to that path, and not include it in their definitions. The handler we\ncreate will return HAL-JSON, and thus need to generate links using the\nconfigured router and base path.  To begin, we will alter the  ConfigProvider  for our module to add the\ndefinitions noted below:  // in src/Api/ConfigProvider.php:\nnamespace Api;\n\nuse Zend\\Expressive\\Hal\\LinkGeneratorFactory;\nuse Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory;\nuse Zend\\Expressive\\Hal\\Metadata\\MetadataMap;\nuse Zend\\Expressive\\Hal\\ResourceGeneratorFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouterFactory;\n\nclass ConfigProvider\n{\n    public function __invoke() : array\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            MetadataMap::class => $this->getMetadataMap(),\n        ];\n    }\n\n    public function getDependencies() : array\n    {\n        return [\n            'factories' => [\n                // module-specific class name => factory\n                LinkGenerator::class          => new LinkGeneratorFactory(UrlGenerator::class),\n                ResourceGenerator::class      => new ResourceGeneratorFactory(LinkGenerator::class),\n                Router::class                 => FastRouteRouterFactory::class,\n                RouteMiddleware::class        => new RouteMiddlewareFactory(Router::class),\n                UrlHelper::class              => new UrlHelperFactory('/api', Router::class),\n                UrlHelperMiddleware::class    => new UrlHelperMiddlewareFactory(UrlHelper::class),\n                UrlGenerator::class           => new ExpressiveUrlGeneratorFactory(UrlHelper::class),\n\n                // Our handler:\n                CreateBookHandler::class => CreateBookHandlerFactory::class,\n\n                // And our pipeline:\n                Pipeline::class => PipelineFactory::class,\n            ],\n        ];\n    }\n\n    public function getMetadataMap() : array\n    {\n        return [\n            // ...\n        ];\n    }\n}  Note that the majority of these service names are  virtual ; they do not resolve\nto actual classes. PHP allows usage of the  ::class  pseudo-constant anywhere,\nand will resolve the value based on the current namespace. This gives us virtual\nservices such as  Api\\Router ,  Api\\UrlHelper , etc.  Also note that we are creating factory  instances . Normally, we recommend not\nusing closures or instances for factories due to potential problems with\nconfiguration caching. Fortunately, we have provided functionality in each of\nthese factories that allows them to be safely cached, retaining the\ncontext-specific configuration required.",
            "title": "Virtual services"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#what-about-the-hard-coded-path",
            "text": "You'll note that the above example hard-codes the base path for the UrlHelper . What if you want to use a different path?  You can override the service in an application-specific configuration under config/autoload/ , specifying a different path!  \\Api\\UrlHelper::class => new UrlHelperFactory('/different/path', \\Api\\Router::class),",
            "title": "What about the hard-coded path?"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#using-virtual-services-with-a-handler",
            "text": "Now let's turn to our  CreateBookHandler . We'll define it as follows:  // in src/Api/CreateBookHandler.php:\nnamespace Api;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\nuse Zend\\Expressive\\Hal\\ResourceGenerator;\n\nclass CreateBookHandler implements RequestHandlerInterface\n{\n    private $resourceGenerator;\n\n    private $responseFactory;\n\n    public function __construct(ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory)\n    {\n        $this->resourceGenerator = $resourceGenerator;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // do some work ...\n\n        $resource = $this->resourceGenerator->fromObject($book, $request);\n        return $this->responseFactory->createResponse($request, $book);\n    }\n}  This handler needs a HAL resource generator. More specifically, it needs the one\nspecific to our module. As such, we'll define our factory as follows:  // in src/Api/CreateBookHandlerFactory.php:\nnamespace Api;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Hal\\HalResponseFactory;\n\nclass CreateBookHandlerFactory\n{\n    public function __invoke(ContainerInterface $container) : CreateBookHandler\n    {\n        return new CreateBookHandler(\n            ResourceGenerator::class, // module-specific service name!\n            HalResponseFactory::class\n        );\n    }\n}  You can create any number of such handlers for your module; the above\ndemonstrates how and where injection of the alternate resource generator occurs.",
            "title": "Using virtual services with a handler"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#creating-our-pipeline-and-routes",
            "text": "Now we can create our pipeline and routes.  Generally when piping to an application instance, we can specify a class name of\nmiddleware to pipe, or an array of middleware:  // in config/pipeline.php:\n$app->pipe('/api', [\n    \\Zend\\ProblemDetails\\ProblemDetailsMiddleware::class,\n    \\Api\\RouteMiddleware::class,     // module-specific routing middleware!\n    ImplicitHeadMiddleware::class,\n    ImplicitOptionsMiddleware::class,\n    MethodNotAllowedMiddleware::class,\n    \\Api\\UrlHelperMiddleware::class, // module-specific URL helper middleware!\n    DispatchMiddleware::class,\n    \\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class,\n]);  However, we have both the pipeline  and  routes, and we likely want to indicate\nthe exact behavior of this pipeline. Additionally, we may want to re-use this\npipeline in other applications; pushing this into the application configuration\nmakes that more error-prone.  As such, we will create a factory that generates and returns a Zend\\Stratigility\\MiddlewarePipe  instance that is fully configured for our\nmodule. As part of this functionality, we will also add our module-specific\nrouting.  // In src/Api/PipelineFactory.php:\nnamespace Api;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Router\\Middleware as RouterMiddleware;\nuse Zend\\Expressive\\Router\\RouteCollector;\nuse Zend\\ProblemDetails\\ProblemDetailsMiddleware;\nuse Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass PipelineFactory\n{\n    public function __invoke(ContainerInterface $container) : MiddlewarePipe\n    {\n        $factory = $container->get(MiddlewareFactory::class);\n\n        // First, create our middleware pipeline\n        $pipeline = new MiddlewarePipe();\n        $pipeline->pipe($factory->lazy(ProblemDetailsMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouteMiddleware::class)); // module-specific!\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitHeadMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitOptionsMiddleware::class));\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\MethodNotAllowedMiddleware::class));\n        $pipeline->pipe($factory->lazy(UrlHelperMiddleware::class)); // module-specific!\n        $pipeline->pipe($factory->lazy(RouterMiddleware\\DispatchMiddleware::class));\n        $pipeline->pipe($factory->lazy(ProblemDetailsNotFoundHandler::class));\n\n        // Second, we'll create our routes\n        $router = $container->get(Router::class); // Retrieve our module-specific router\n        $routes = new RouteCollector($router);    // Create a route collector to simplify routing\n\n        // Start routing:\n        $routes->post('/books', $factory->lazy(CreateBookHandler::class));\n\n        // Return the pipeline now that we're done!\n        return $pipeline;\n    }\n}  Note that the routing definitions do  not  include the prefix  /api ; this is\nbecause that prefix will be stripped when we path-segregate our API middleware\npipeline. All routing will be  relative  to that path.",
            "title": "Creating our pipeline and routes"
        },
        {
            "location": "/cookbook/path-segregated-uri-generation/#creating-a-path-segregated-pipeline",
            "text": "Finally, we will attach our pipeline to the application, using path segregation:  // in config/pipeline.php:\n$app->pipe('/api', \\Api\\Pipeline::class);  This statement tells the application to pipe the pipeline returned by our PipelineFactory  under the path  /api ; that path will be stripped from\nrequests when passed to the underlying middleware.  At this point, we now have a re-usable module, complete with its own routing,\nwith URI generation that will include the base path under which we have\nsegregated the pipeline!",
            "title": "Creating a path-segregated pipeline"
        }
    ]
}